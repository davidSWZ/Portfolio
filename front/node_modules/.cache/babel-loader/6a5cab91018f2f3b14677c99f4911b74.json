{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = e(require(\"react\")) : \"function\" == typeof define && define.amd ? define(\"react-jsx-parser\", [\"react\"], e) : \"object\" == typeof exports ? exports[\"react-jsx-parser\"] = e(require(\"react\")) : t[\"react-jsx-parser\"] = e(t.react);\n}(this, function (t) {\n  return function (t) {\n    var e = {};\n\n    function i(s) {\n      if (e[s]) return e[s].exports;\n      var r = e[s] = {\n        i: s,\n        l: !1,\n        exports: {}\n      };\n      return t[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n    }\n\n    return i.m = t, i.c = e, i.d = function (t, e, s) {\n      i.o(t, e) || Object.defineProperty(t, e, {\n        enumerable: !0,\n        get: s\n      });\n    }, i.r = function (t) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, i.t = function (t, e) {\n      if (1 & e && (t = i(t)), 8 & e) return t;\n      if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n      var s = Object.create(null);\n      if (i.r(s), Object.defineProperty(s, \"default\", {\n        enumerable: !0,\n        value: t\n      }), 2 & e && \"string\" != typeof t) for (var r in t) i.d(s, r, function (e) {\n        return t[e];\n      }.bind(null, r));\n      return s;\n    }, i.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return i.d(e, \"a\", e), e;\n    }, i.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, i.p = \"\", i(i.s = 5);\n  }([function (e, i) {\n    e.exports = t;\n  }, function (t, e, i) {\n    \"use strict\";\n\n    t.exports = i(2)(i(4));\n  }, function (t, e, i) {\n    \"use strict\";\n\n    var s = i(3),\n        r = /^[\\da-fA-F]+$/,\n        n = /^\\d+$/;\n\n    t.exports = function (t) {\n      var e = t.tokTypes,\n          i = t.tokContexts;\n      i.j_oTag = new t.TokContext(\"<tag\", !1), i.j_cTag = new t.TokContext(\"</tag\", !1), i.j_expr = new t.TokContext(\"<tag>...</tag>\", !0, !0), e.jsxName = new t.TokenType(\"jsxName\"), e.jsxText = new t.TokenType(\"jsxText\", {\n        beforeExpr: !0\n      }), e.jsxTagStart = new t.TokenType(\"jsxTagStart\"), e.jsxTagEnd = new t.TokenType(\"jsxTagEnd\"), e.jsxTagStart.updateContext = function () {\n        this.context.push(i.j_expr), this.context.push(i.j_oTag), this.exprAllowed = !1;\n      }, e.jsxTagEnd.updateContext = function (t) {\n        var s = this.context.pop();\n        s === i.j_oTag && t === e.slash || s === i.j_cTag ? (this.context.pop(), this.exprAllowed = this.curContext() === i.j_expr) : this.exprAllowed = !0;\n      };\n      var a = t.Parser.prototype;\n\n      function o(t) {\n        return t ? \"JSXIdentifier\" === t.type ? t.name : \"JSXNamespacedName\" === t.type ? t.namespace.name + \":\" + t.name.name : \"JSXMemberExpression\" === t.type ? o(t.object) + \".\" + o(t.property) : void 0 : t;\n      }\n\n      return a.jsx_readToken = function () {\n        for (var i = \"\", s = this.pos;;) {\n          this.pos >= this.input.length && this.raise(this.start, \"Unterminated JSX contents\");\n          var r = this.input.charCodeAt(this.pos);\n\n          switch (r) {\n            case 60:\n            case 123:\n              return this.pos === this.start ? 60 === r && this.exprAllowed ? (++this.pos, this.finishToken(e.jsxTagStart)) : this.getTokenFromCode(r) : (i += this.input.slice(s, this.pos), this.finishToken(e.jsxText, i));\n\n            case 38:\n              i += this.input.slice(s, this.pos), i += this.jsx_readEntity(), s = this.pos;\n              break;\n\n            default:\n              t.isNewLine(r) ? (i += this.input.slice(s, this.pos), i += this.jsx_readNewLine(!0), s = this.pos) : ++this.pos;\n          }\n        }\n      }, a.jsx_readNewLine = function (t) {\n        var e,\n            i = this.input.charCodeAt(this.pos);\n        return ++this.pos, 13 === i && 10 === this.input.charCodeAt(this.pos) ? (++this.pos, e = t ? \"\\n\" : \"\\r\\n\") : e = String.fromCharCode(i), this.options.locations && (++this.curLine, this.lineStart = this.pos), e;\n      }, a.jsx_readString = function (i) {\n        for (var s = \"\", r = ++this.pos;;) {\n          this.pos >= this.input.length && this.raise(this.start, \"Unterminated string constant\");\n          var n = this.input.charCodeAt(this.pos);\n          if (n === i) break;\n          38 === n ? (s += this.input.slice(r, this.pos), s += this.jsx_readEntity(), r = this.pos) : t.isNewLine(n) ? (s += this.input.slice(r, this.pos), s += this.jsx_readNewLine(!1), r = this.pos) : ++this.pos;\n        }\n\n        return s += this.input.slice(r, this.pos++), this.finishToken(e.string, s);\n      }, a.jsx_readEntity = function () {\n        var t,\n            e = \"\",\n            i = 0,\n            a = this.input[this.pos];\n        \"&\" !== a && this.raise(this.pos, \"Entity must start with an ampersand\");\n\n        for (var o = ++this.pos; this.pos < this.input.length && i++ < 10;) {\n          if (\";\" === (a = this.input[this.pos++])) {\n            \"#\" === e[0] ? \"x\" === e[1] ? (e = e.substr(2), r.test(e) && (t = String.fromCharCode(parseInt(e, 16)))) : (e = e.substr(1), n.test(e) && (t = String.fromCharCode(parseInt(e, 10)))) : t = s[e];\n            break;\n          }\n\n          e += a;\n        }\n\n        return t || (this.pos = o, \"&\");\n      }, a.jsx_readWord = function () {\n        var i,\n            s = this.pos;\n\n        do {\n          i = this.input.charCodeAt(++this.pos);\n        } while (t.isIdentifierChar(i) || 45 === i);\n\n        return this.finishToken(e.jsxName, this.input.slice(s, this.pos));\n      }, a.jsx_parseIdentifier = function () {\n        var t = this.startNode();\n        return this.type === e.jsxName ? t.name = this.value : this.type.keyword ? t.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(t, \"JSXIdentifier\");\n      }, a.jsx_parseNamespacedName = function () {\n        var t = this.start,\n            i = this.startLoc,\n            s = this.jsx_parseIdentifier();\n        if (!this.options.plugins.jsx.allowNamespaces || !this.eat(e.colon)) return s;\n        var r = this.startNodeAt(t, i);\n        return r.namespace = s, r.name = this.jsx_parseIdentifier(), this.finishNode(r, \"JSXNamespacedName\");\n      }, a.jsx_parseElementName = function () {\n        if (this.type === e.jsxTagEnd) return \"\";\n        var t = this.start,\n            i = this.startLoc,\n            s = this.jsx_parseNamespacedName();\n\n        for (this.type !== e.dot || \"JSXNamespacedName\" !== s.type || this.options.plugins.jsx.allowNamespacedObjects || this.unexpected(); this.eat(e.dot);) {\n          var r = this.startNodeAt(t, i);\n          r.object = s, r.property = this.jsx_parseIdentifier(), s = this.finishNode(r, \"JSXMemberExpression\");\n        }\n\n        return s;\n      }, a.jsx_parseAttributeValue = function () {\n        switch (this.type) {\n          case e.braceL:\n            var t = this.jsx_parseExpressionContainer();\n            return \"JSXEmptyExpression\" === t.expression.type && this.raise(t.start, \"JSX attributes must only be assigned a non-empty expression\"), t;\n\n          case e.jsxTagStart:\n          case e.string:\n            return this.parseExprAtom();\n\n          default:\n            this.raise(this.start, \"JSX value should be either an expression or a quoted JSX text\");\n        }\n      }, a.jsx_parseEmptyExpression = function () {\n        var t = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n        return this.finishNodeAt(t, \"JSXEmptyExpression\", this.start, this.startLoc);\n      }, a.jsx_parseExpressionContainer = function () {\n        var t = this.startNode();\n        return this.next(), t.expression = this.type === e.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(e.braceR), this.finishNode(t, \"JSXExpressionContainer\");\n      }, a.jsx_parseAttribute = function () {\n        var t = this.startNode();\n        return this.eat(e.braceL) ? (this.expect(e.ellipsis), t.argument = this.parseMaybeAssign(), this.expect(e.braceR), this.finishNode(t, \"JSXSpreadAttribute\")) : (t.name = this.jsx_parseNamespacedName(), t.value = this.eat(e.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(t, \"JSXAttribute\"));\n      }, a.jsx_parseOpeningElementAt = function (t, i) {\n        var s = this.startNodeAt(t, i);\n        s.attributes = [];\n        var r = this.jsx_parseElementName();\n\n        for (r && (s.name = r); this.type !== e.slash && this.type !== e.jsxTagEnd;) s.attributes.push(this.jsx_parseAttribute());\n\n        return s.selfClosing = this.eat(e.slash), this.expect(e.jsxTagEnd), this.finishNode(s, r ? \"JSXOpeningElement\" : \"JSXOpeningFragment\");\n      }, a.jsx_parseClosingElementAt = function (t, i) {\n        var s = this.startNodeAt(t, i),\n            r = this.jsx_parseElementName();\n        return r && (s.name = r), this.expect(e.jsxTagEnd), this.finishNode(s, r ? \"JSXClosingElement\" : \"JSXClosingFragment\");\n      }, a.jsx_parseElementAt = function (t, i) {\n        var s = this.startNodeAt(t, i),\n            r = [],\n            n = this.jsx_parseOpeningElementAt(t, i),\n            a = null;\n\n        if (!n.selfClosing) {\n          t: for (;;) switch (this.type) {\n            case e.jsxTagStart:\n              if (t = this.start, i = this.startLoc, this.next(), this.eat(e.slash)) {\n                a = this.jsx_parseClosingElementAt(t, i);\n                break t;\n              }\n\n              r.push(this.jsx_parseElementAt(t, i));\n              break;\n\n            case e.jsxText:\n              r.push(this.parseExprAtom());\n              break;\n\n            case e.braceL:\n              r.push(this.jsx_parseExpressionContainer());\n              break;\n\n            default:\n              this.unexpected();\n          }\n\n          o(a.name) !== o(n.name) && this.raise(a.start, \"Expected corresponding JSX closing tag for <\" + o(n.name) + \">\");\n        }\n\n        return s.openingElement = n, s.closingElement = a, s.children = r, this.type === e.relational && \"<\" === this.value && this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\"), this.finishNode(s, n.name ? \"JSXElement\" : \"JSXFragment\");\n      }, a.jsx_parseText = function (t) {\n        var e = this.parseLiteral(t);\n        return e.type = \"JSXText\", e;\n      }, a.jsx_parseElement = function () {\n        var t = this.start,\n            e = this.startLoc;\n        return this.next(), this.jsx_parseElementAt(t, e);\n      }, t.plugins.jsx = function (s, r) {\n        r && (\"object\" != typeof r && (r = {}), s.options.plugins.jsx = {\n          allowNamespaces: !1 !== r.allowNamespaces,\n          allowNamespacedObjects: !!r.allowNamespacedObjects\n        }, s.extend(\"parseExprAtom\", function (t) {\n          return function (i) {\n            return this.type === e.jsxText ? this.jsx_parseText(this.value) : this.type === e.jsxTagStart ? this.jsx_parseElement() : t.call(this, i);\n          };\n        }), s.extend(\"readToken\", function (s) {\n          return function (r) {\n            var n = this.curContext();\n            if (n === i.j_expr) return this.jsx_readToken();\n\n            if (n === i.j_oTag || n === i.j_cTag) {\n              if (t.isIdentifierStart(r)) return this.jsx_readWord();\n              if (62 == r) return ++this.pos, this.finishToken(e.jsxTagEnd);\n              if ((34 === r || 39 === r) && n == i.j_oTag) return this.jsx_readString(r);\n            }\n\n            return 60 === r && this.exprAllowed && 33 !== this.input.charCodeAt(this.pos + 1) ? (++this.pos, this.finishToken(e.jsxTagStart)) : s.call(this, r);\n          };\n        }), s.extend(\"updateContext\", function (t) {\n          return function (s) {\n            if (this.type == e.braceL) {\n              var r = this.curContext();\n              r == i.j_oTag ? this.context.push(i.b_expr) : r == i.j_expr ? this.context.push(i.b_tmpl) : t.call(this, s), this.exprAllowed = !0;\n            } else {\n              if (this.type !== e.slash || s !== e.jsxTagStart) return t.call(this, s);\n              this.context.length -= 2, this.context.push(i.j_cTag), this.exprAllowed = !1;\n            }\n          };\n        }));\n      }, t;\n    };\n  }, function (t, e) {\n    t.exports = {\n      quot: '\"',\n      amp: \"&\",\n      apos: \"'\",\n      lt: \"<\",\n      gt: \">\",\n      nbsp: \" \",\n      iexcl: \"¡\",\n      cent: \"¢\",\n      pound: \"£\",\n      curren: \"¤\",\n      yen: \"¥\",\n      brvbar: \"¦\",\n      sect: \"§\",\n      uml: \"¨\",\n      copy: \"©\",\n      ordf: \"ª\",\n      laquo: \"«\",\n      not: \"¬\",\n      shy: \"­\",\n      reg: \"®\",\n      macr: \"¯\",\n      deg: \"°\",\n      plusmn: \"±\",\n      sup2: \"²\",\n      sup3: \"³\",\n      acute: \"´\",\n      micro: \"µ\",\n      para: \"¶\",\n      middot: \"·\",\n      cedil: \"¸\",\n      sup1: \"¹\",\n      ordm: \"º\",\n      raquo: \"»\",\n      frac14: \"¼\",\n      frac12: \"½\",\n      frac34: \"¾\",\n      iquest: \"¿\",\n      Agrave: \"À\",\n      Aacute: \"Á\",\n      Acirc: \"Â\",\n      Atilde: \"Ã\",\n      Auml: \"Ä\",\n      Aring: \"Å\",\n      AElig: \"Æ\",\n      Ccedil: \"Ç\",\n      Egrave: \"È\",\n      Eacute: \"É\",\n      Ecirc: \"Ê\",\n      Euml: \"Ë\",\n      Igrave: \"Ì\",\n      Iacute: \"Í\",\n      Icirc: \"Î\",\n      Iuml: \"Ï\",\n      ETH: \"Ð\",\n      Ntilde: \"Ñ\",\n      Ograve: \"Ò\",\n      Oacute: \"Ó\",\n      Ocirc: \"Ô\",\n      Otilde: \"Õ\",\n      Ouml: \"Ö\",\n      times: \"×\",\n      Oslash: \"Ø\",\n      Ugrave: \"Ù\",\n      Uacute: \"Ú\",\n      Ucirc: \"Û\",\n      Uuml: \"Ü\",\n      Yacute: \"Ý\",\n      THORN: \"Þ\",\n      szlig: \"ß\",\n      agrave: \"à\",\n      aacute: \"á\",\n      acirc: \"â\",\n      atilde: \"ã\",\n      auml: \"ä\",\n      aring: \"å\",\n      aelig: \"æ\",\n      ccedil: \"ç\",\n      egrave: \"è\",\n      eacute: \"é\",\n      ecirc: \"ê\",\n      euml: \"ë\",\n      igrave: \"ì\",\n      iacute: \"í\",\n      icirc: \"î\",\n      iuml: \"ï\",\n      eth: \"ð\",\n      ntilde: \"ñ\",\n      ograve: \"ò\",\n      oacute: \"ó\",\n      ocirc: \"ô\",\n      otilde: \"õ\",\n      ouml: \"ö\",\n      divide: \"÷\",\n      oslash: \"ø\",\n      ugrave: \"ù\",\n      uacute: \"ú\",\n      ucirc: \"û\",\n      uuml: \"ü\",\n      yacute: \"ý\",\n      thorn: \"þ\",\n      yuml: \"ÿ\",\n      OElig: \"Œ\",\n      oelig: \"œ\",\n      Scaron: \"Š\",\n      scaron: \"š\",\n      Yuml: \"Ÿ\",\n      fnof: \"ƒ\",\n      circ: \"ˆ\",\n      tilde: \"˜\",\n      Alpha: \"Α\",\n      Beta: \"Β\",\n      Gamma: \"Γ\",\n      Delta: \"Δ\",\n      Epsilon: \"Ε\",\n      Zeta: \"Ζ\",\n      Eta: \"Η\",\n      Theta: \"Θ\",\n      Iota: \"Ι\",\n      Kappa: \"Κ\",\n      Lambda: \"Λ\",\n      Mu: \"Μ\",\n      Nu: \"Ν\",\n      Xi: \"Ξ\",\n      Omicron: \"Ο\",\n      Pi: \"Π\",\n      Rho: \"Ρ\",\n      Sigma: \"Σ\",\n      Tau: \"Τ\",\n      Upsilon: \"Υ\",\n      Phi: \"Φ\",\n      Chi: \"Χ\",\n      Psi: \"Ψ\",\n      Omega: \"Ω\",\n      alpha: \"α\",\n      beta: \"β\",\n      gamma: \"γ\",\n      delta: \"δ\",\n      epsilon: \"ε\",\n      zeta: \"ζ\",\n      eta: \"η\",\n      theta: \"θ\",\n      iota: \"ι\",\n      kappa: \"κ\",\n      lambda: \"λ\",\n      mu: \"μ\",\n      nu: \"ν\",\n      xi: \"ξ\",\n      omicron: \"ο\",\n      pi: \"π\",\n      rho: \"ρ\",\n      sigmaf: \"ς\",\n      sigma: \"σ\",\n      tau: \"τ\",\n      upsilon: \"υ\",\n      phi: \"φ\",\n      chi: \"χ\",\n      psi: \"ψ\",\n      omega: \"ω\",\n      thetasym: \"ϑ\",\n      upsih: \"ϒ\",\n      piv: \"ϖ\",\n      ensp: \" \",\n      emsp: \" \",\n      thinsp: \" \",\n      zwnj: \"‌\",\n      zwj: \"‍\",\n      lrm: \"‎\",\n      rlm: \"‏\",\n      ndash: \"–\",\n      mdash: \"—\",\n      lsquo: \"‘\",\n      rsquo: \"’\",\n      sbquo: \"‚\",\n      ldquo: \"“\",\n      rdquo: \"”\",\n      bdquo: \"„\",\n      dagger: \"†\",\n      Dagger: \"‡\",\n      bull: \"•\",\n      hellip: \"…\",\n      permil: \"‰\",\n      prime: \"′\",\n      Prime: \"″\",\n      lsaquo: \"‹\",\n      rsaquo: \"›\",\n      oline: \"‾\",\n      frasl: \"⁄\",\n      euro: \"€\",\n      image: \"ℑ\",\n      weierp: \"℘\",\n      real: \"ℜ\",\n      trade: \"™\",\n      alefsym: \"ℵ\",\n      larr: \"←\",\n      uarr: \"↑\",\n      rarr: \"→\",\n      darr: \"↓\",\n      harr: \"↔\",\n      crarr: \"↵\",\n      lArr: \"⇐\",\n      uArr: \"⇑\",\n      rArr: \"⇒\",\n      dArr: \"⇓\",\n      hArr: \"⇔\",\n      forall: \"∀\",\n      part: \"∂\",\n      exist: \"∃\",\n      empty: \"∅\",\n      nabla: \"∇\",\n      isin: \"∈\",\n      notin: \"∉\",\n      ni: \"∋\",\n      prod: \"∏\",\n      sum: \"∑\",\n      minus: \"−\",\n      lowast: \"∗\",\n      radic: \"√\",\n      prop: \"∝\",\n      infin: \"∞\",\n      ang: \"∠\",\n      and: \"∧\",\n      or: \"∨\",\n      cap: \"∩\",\n      cup: \"∪\",\n      int: \"∫\",\n      there4: \"∴\",\n      sim: \"∼\",\n      cong: \"≅\",\n      asymp: \"≈\",\n      ne: \"≠\",\n      equiv: \"≡\",\n      le: \"≤\",\n      ge: \"≥\",\n      sub: \"⊂\",\n      sup: \"⊃\",\n      nsub: \"⊄\",\n      sube: \"⊆\",\n      supe: \"⊇\",\n      oplus: \"⊕\",\n      otimes: \"⊗\",\n      perp: \"⊥\",\n      sdot: \"⋅\",\n      lceil: \"⌈\",\n      rceil: \"⌉\",\n      lfloor: \"⌊\",\n      rfloor: \"⌋\",\n      lang: \"〈\",\n      rang: \"〉\",\n      loz: \"◊\",\n      spades: \"♠\",\n      clubs: \"♣\",\n      hearts: \"♥\",\n      diams: \"♦\"\n    };\n  }, function (t, e, i) {\n    \"use strict\";\n\n    i.r(e), i.d(e, \"version\", function () {\n      return wt;\n    }), i.d(e, \"parse\", function () {\n      return Ct;\n    }), i.d(e, \"parseExpressionAt\", function () {\n      return At;\n    }), i.d(e, \"tokenizer\", function () {\n      return Tt;\n    }), i.d(e, \"parse_dammit\", function () {\n      return kt;\n    }), i.d(e, \"LooseParser\", function () {\n      return Et;\n    }), i.d(e, \"pluginsLoose\", function () {\n      return St;\n    }), i.d(e, \"addLooseExports\", function () {\n      return Pt;\n    }), i.d(e, \"Parser\", function () {\n      return F;\n    }), i.d(e, \"plugins\", function () {\n      return M;\n    }), i.d(e, \"defaultOptions\", function () {\n      return R;\n    }), i.d(e, \"Position\", function () {\n      return V;\n    }), i.d(e, \"SourceLocation\", function () {\n      return j;\n    }), i.d(e, \"getLineInfo\", function () {\n      return O;\n    }), i.d(e, \"Node\", function () {\n      return tt;\n    }), i.d(e, \"TokenType\", function () {\n      return x;\n    }), i.d(e, \"tokTypes\", function () {\n      return k;\n    }), i.d(e, \"keywordTypes\", function () {\n      return b;\n    }), i.d(e, \"TokContext\", function () {\n      return st;\n    }), i.d(e, \"tokContexts\", function () {\n      return rt;\n    }), i.d(e, \"isIdentifierChar\", function () {\n      return m;\n    }), i.d(e, \"isIdentifierStart\", function () {\n      return f;\n    }), i.d(e, \"Token\", function () {\n      return yt;\n    }), i.d(e, \"isNewLine\", function () {\n      return w;\n    }), i.d(e, \"lineBreak\", function () {\n      return E;\n    }), i.d(e, \"lineBreakG\", function () {\n      return S;\n    }), i.d(e, \"nonASCIIwhitespace\", function () {\n      return C;\n    });\n    var s = {\n      3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n      5: \"class enum extends super const export import\",\n      6: \"enum\",\n      strict: \"implements interface let package private protected public static yield\",\n      strictBind: \"eval arguments\"\n    },\n        r = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\",\n        n = {\n      5: r,\n      6: r + \" const class extends export import super\"\n    },\n        a = /^in(stanceof)?$/,\n        o = \"ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿯ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞹꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ\",\n        h = \"‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿\",\n        p = new RegExp(\"[\" + o + \"]\"),\n        c = new RegExp(\"[\" + o + h + \"]\");\n    o = h = null;\n    var u = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 190, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 26, 230, 43, 117, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 68, 12, 0, 67, 12, 65, 1, 31, 6129, 15, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541],\n        l = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];\n\n    function d(t, e) {\n      for (var i = 65536, s = 0; s < e.length; s += 2) {\n        if ((i += e[s]) > t) return !1;\n        if ((i += e[s + 1]) >= t) return !0;\n      }\n    }\n\n    function f(t, e) {\n      return t < 65 ? 36 === t : t < 91 || (t < 97 ? 95 === t : t < 123 || (t <= 65535 ? t >= 170 && p.test(String.fromCharCode(t)) : !1 !== e && d(t, u)));\n    }\n\n    function m(t, e) {\n      return t < 48 ? 36 === t : t < 58 || !(t < 65) && (t < 91 || (t < 97 ? 95 === t : t < 123 || (t <= 65535 ? t >= 170 && c.test(String.fromCharCode(t)) : !1 !== e && (d(t, u) || d(t, l)))));\n    }\n\n    var x = function (t, e) {\n      void 0 === e && (e = {}), this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop || null, this.updateContext = null;\n    };\n\n    function g(t, e) {\n      return new x(t, {\n        beforeExpr: !0,\n        binop: e\n      });\n    }\n\n    var y = {\n      beforeExpr: !0\n    },\n        v = {\n      startsExpr: !0\n    },\n        b = {};\n\n    function _(t, e) {\n      return void 0 === e && (e = {}), e.keyword = t, b[t] = new x(t, e);\n    }\n\n    var k = {\n      num: new x(\"num\", v),\n      regexp: new x(\"regexp\", v),\n      string: new x(\"string\", v),\n      name: new x(\"name\", v),\n      eof: new x(\"eof\"),\n      bracketL: new x(\"[\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      bracketR: new x(\"]\"),\n      braceL: new x(\"{\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      braceR: new x(\"}\"),\n      parenL: new x(\"(\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      parenR: new x(\")\"),\n      comma: new x(\",\", y),\n      semi: new x(\";\", y),\n      colon: new x(\":\", y),\n      dot: new x(\".\"),\n      question: new x(\"?\", y),\n      arrow: new x(\"=>\", y),\n      template: new x(\"template\"),\n      invalidTemplate: new x(\"invalidTemplate\"),\n      ellipsis: new x(\"...\", y),\n      backQuote: new x(\"`\", v),\n      dollarBraceL: new x(\"${\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      eq: new x(\"=\", {\n        beforeExpr: !0,\n        isAssign: !0\n      }),\n      assign: new x(\"_=\", {\n        beforeExpr: !0,\n        isAssign: !0\n      }),\n      incDec: new x(\"++/--\", {\n        prefix: !0,\n        postfix: !0,\n        startsExpr: !0\n      }),\n      prefix: new x(\"!/~\", {\n        beforeExpr: !0,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      logicalOR: g(\"||\", 1),\n      logicalAND: g(\"&&\", 2),\n      bitwiseOR: g(\"|\", 3),\n      bitwiseXOR: g(\"^\", 4),\n      bitwiseAND: g(\"&\", 5),\n      equality: g(\"==/!=/===/!==\", 6),\n      relational: g(\"</>/<=/>=\", 7),\n      bitShift: g(\"<</>>/>>>\", 8),\n      plusMin: new x(\"+/-\", {\n        beforeExpr: !0,\n        binop: 9,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      modulo: g(\"%\", 10),\n      star: g(\"*\", 10),\n      slash: g(\"/\", 10),\n      starstar: new x(\"**\", {\n        beforeExpr: !0\n      }),\n      _break: _(\"break\"),\n      _case: _(\"case\", y),\n      _catch: _(\"catch\"),\n      _continue: _(\"continue\"),\n      _debugger: _(\"debugger\"),\n      _default: _(\"default\", y),\n      _do: _(\"do\", {\n        isLoop: !0,\n        beforeExpr: !0\n      }),\n      _else: _(\"else\", y),\n      _finally: _(\"finally\"),\n      _for: _(\"for\", {\n        isLoop: !0\n      }),\n      _function: _(\"function\", v),\n      _if: _(\"if\"),\n      _return: _(\"return\", y),\n      _switch: _(\"switch\"),\n      _throw: _(\"throw\", y),\n      _try: _(\"try\"),\n      _var: _(\"var\"),\n      _const: _(\"const\"),\n      _while: _(\"while\", {\n        isLoop: !0\n      }),\n      _with: _(\"with\"),\n      _new: _(\"new\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      _this: _(\"this\", v),\n      _super: _(\"super\", v),\n      _class: _(\"class\", v),\n      _extends: _(\"extends\", y),\n      _export: _(\"export\"),\n      _import: _(\"import\"),\n      _null: _(\"null\", v),\n      _true: _(\"true\", v),\n      _false: _(\"false\", v),\n      _in: _(\"in\", {\n        beforeExpr: !0,\n        binop: 7\n      }),\n      _instanceof: _(\"instanceof\", {\n        beforeExpr: !0,\n        binop: 7\n      }),\n      _typeof: _(\"typeof\", {\n        beforeExpr: !0,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      _void: _(\"void\", {\n        beforeExpr: !0,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      _delete: _(\"delete\", {\n        beforeExpr: !0,\n        prefix: !0,\n        startsExpr: !0\n      })\n    },\n        E = /\\r\\n?|\\n|\\u2028|\\u2029/,\n        S = new RegExp(E.source, \"g\");\n\n    function w(t, e) {\n      return 10 === t || 13 === t || !e && (8232 === t || 8233 === t);\n    }\n\n    var C = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/,\n        A = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g,\n        T = Object.prototype,\n        P = T.hasOwnProperty,\n        N = T.toString;\n\n    function I(t, e) {\n      return P.call(t, e);\n    }\n\n    var L = Array.isArray || function (t) {\n      return \"[object Array]\" === N.call(t);\n    },\n        V = function (t, e) {\n      this.line = t, this.column = e;\n    };\n\n    V.prototype.offset = function (t) {\n      return new V(this.line, this.column + t);\n    };\n\n    var j = function (t, e, i) {\n      this.start = e, this.end = i, null !== t.sourceFile && (this.source = t.sourceFile);\n    };\n\n    function O(t, e) {\n      for (var i = 1, s = 0;;) {\n        S.lastIndex = s;\n        var r = S.exec(t);\n        if (!(r && r.index < e)) return new V(i, e - s);\n        ++i, s = r.index + r[0].length;\n      }\n    }\n\n    var R = {\n      ecmaVersion: 7,\n      sourceType: \"script\",\n      onInsertedSemicolon: null,\n      onTrailingComma: null,\n      allowReserved: null,\n      allowReturnOutsideFunction: !1,\n      allowImportExportEverywhere: !1,\n      allowAwaitOutsideFunction: !1,\n      allowHashBang: !1,\n      locations: !1,\n      onToken: null,\n      onComment: null,\n      ranges: !1,\n      program: null,\n      sourceFile: null,\n      directSourceFile: null,\n      preserveParens: !1,\n      plugins: {}\n    };\n\n    function D(t) {\n      var e = {};\n\n      for (var i in R) e[i] = t && I(t, i) ? t[i] : R[i];\n\n      if (e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009), null == e.allowReserved && (e.allowReserved = e.ecmaVersion < 5), L(e.onToken)) {\n        var s = e.onToken;\n\n        e.onToken = function (t) {\n          return s.push(t);\n        };\n      }\n\n      return L(e.onComment) && (e.onComment = function (t, e) {\n        return function (i, s, r, n, a, o) {\n          var h = {\n            type: i ? \"Block\" : \"Line\",\n            value: s,\n            start: r,\n            end: n\n          };\n          t.locations && (h.loc = new j(this, a, o)), t.ranges && (h.range = [r, n]), e.push(h);\n        };\n      }(e, e.onComment)), e;\n    }\n\n    var M = {};\n\n    function B(t) {\n      return new RegExp(\"^(?:\" + t.replace(/ /g, \"|\") + \")$\");\n    }\n\n    var F = function (t, e, i) {\n      this.options = t = D(t), this.sourceFile = t.sourceFile, this.keywords = B(n[t.ecmaVersion >= 6 ? 6 : 5]);\n      var r = \"\";\n\n      if (!t.allowReserved) {\n        for (var a = t.ecmaVersion; !(r = s[a]); a--);\n\n        \"module\" === t.sourceType && (r += \" await\");\n      }\n\n      this.reservedWords = B(r);\n      var o = (r ? r + \" \" : \"\") + s.strict;\n      this.reservedWordsStrict = B(o), this.reservedWordsStrictBind = B(o + \" \" + s.strictBind), this.input = String(e), this.containsEsc = !1, this.loadPlugins(t.plugins), i ? (this.pos = i, this.lineStart = this.input.lastIndexOf(\"\\n\", i - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(E).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = k.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = \"module\" === t.sourceType, this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.inFunction = this.inGenerator = this.inAsync = !1, this.yieldPos = this.awaitPos = 0, this.labels = [], 0 === this.pos && t.allowHashBang && \"#!\" === this.input.slice(0, 2) && this.skipLineComment(2), this.scopeStack = [], this.enterFunctionScope(), this.regexpState = null;\n    };\n\n    F.prototype.isKeyword = function (t) {\n      return this.keywords.test(t);\n    }, F.prototype.isReservedWord = function (t) {\n      return this.reservedWords.test(t);\n    }, F.prototype.extend = function (t, e) {\n      this[t] = e(this[t]);\n    }, F.prototype.loadPlugins = function (t) {\n      for (var e in t) {\n        var i = M[e];\n        if (!i) throw new Error(\"Plugin '\" + e + \"' not found\");\n        i(this, t[e]);\n      }\n    }, F.prototype.parse = function () {\n      var t = this.options.program || this.startNode();\n      return this.nextToken(), this.parseTopLevel(t);\n    };\n    var U = F.prototype,\n        q = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\"|;)/;\n\n    function G() {\n      this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n    }\n\n    U.strictDirective = function (t) {\n      for (;;) {\n        A.lastIndex = t, t += A.exec(this.input)[0].length;\n        var e = q.exec(this.input.slice(t));\n        if (!e) return !1;\n        if (\"use strict\" === (e[1] || e[2])) return !0;\n        t += e[0].length;\n      }\n    }, U.eat = function (t) {\n      return this.type === t && (this.next(), !0);\n    }, U.isContextual = function (t) {\n      return this.type === k.name && this.value === t && !this.containsEsc;\n    }, U.eatContextual = function (t) {\n      return !!this.isContextual(t) && (this.next(), !0);\n    }, U.expectContextual = function (t) {\n      this.eatContextual(t) || this.unexpected();\n    }, U.canInsertSemicolon = function () {\n      return this.type === k.eof || this.type === k.braceR || E.test(this.input.slice(this.lastTokEnd, this.start));\n    }, U.insertSemicolon = function () {\n      if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;\n    }, U.semicolon = function () {\n      this.eat(k.semi) || this.insertSemicolon() || this.unexpected();\n    }, U.afterTrailingComma = function (t, e) {\n      if (this.type === t) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), e || this.next(), !0;\n    }, U.expect = function (t) {\n      this.eat(t) || this.unexpected();\n    }, U.unexpected = function (t) {\n      this.raise(null != t ? t : this.start, \"Unexpected token\");\n    }, U.checkPatternErrors = function (t, e) {\n      if (t) {\n        t.trailingComma > -1 && this.raiseRecoverable(t.trailingComma, \"Comma is not permitted after the rest element\");\n        var i = e ? t.parenthesizedAssign : t.parenthesizedBind;\n        i > -1 && this.raiseRecoverable(i, \"Parenthesized pattern\");\n      }\n    }, U.checkExpressionErrors = function (t, e) {\n      if (!t) return !1;\n      var i = t.shorthandAssign,\n          s = t.doubleProto;\n      if (!e) return i >= 0 || s >= 0;\n      i >= 0 && this.raise(i, \"Shorthand property assignments are valid only in destructuring patterns\"), s >= 0 && this.raiseRecoverable(s, \"Redefinition of __proto__ property\");\n    }, U.checkYieldAwaitInDefaultParams = function () {\n      this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, \"Yield expression cannot be a default value\"), this.awaitPos && this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n    }, U.isSimpleAssignTarget = function (t) {\n      return \"ParenthesizedExpression\" === t.type ? this.isSimpleAssignTarget(t.expression) : \"Identifier\" === t.type || \"MemberExpression\" === t.type;\n    };\n    var X = F.prototype;\n\n    X.parseTopLevel = function (t) {\n      var e = {};\n\n      for (t.body || (t.body = []); this.type !== k.eof;) {\n        var i = this.parseStatement(!0, !0, e);\n        t.body.push(i);\n      }\n\n      return this.adaptDirectivePrologue(t.body), this.next(), this.options.ecmaVersion >= 6 && (t.sourceType = this.options.sourceType), this.finishNode(t, \"Program\");\n    };\n\n    var W = {\n      kind: \"loop\"\n    },\n        H = {\n      kind: \"switch\"\n    };\n    X.isLet = function () {\n      if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) return !1;\n      A.lastIndex = this.pos;\n      var t = A.exec(this.input),\n          e = this.pos + t[0].length,\n          i = this.input.charCodeAt(e);\n      if (91 === i || 123 === i) return !0;\n\n      if (f(i, !0)) {\n        for (var s = e + 1; m(this.input.charCodeAt(s), !0);) ++s;\n\n        var r = this.input.slice(e, s);\n        if (!a.test(r)) return !0;\n      }\n\n      return !1;\n    }, X.isAsyncFunction = function () {\n      if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\")) return !1;\n      A.lastIndex = this.pos;\n      var t = A.exec(this.input),\n          e = this.pos + t[0].length;\n      return !(E.test(this.input.slice(this.pos, e)) || \"function\" !== this.input.slice(e, e + 8) || e + 8 !== this.input.length && m(this.input.charAt(e + 8)));\n    }, X.parseStatement = function (t, e, i) {\n      var s,\n          r = this.type,\n          n = this.startNode();\n\n      switch (this.isLet() && (r = k._var, s = \"let\"), r) {\n        case k._break:\n        case k._continue:\n          return this.parseBreakContinueStatement(n, r.keyword);\n\n        case k._debugger:\n          return this.parseDebuggerStatement(n);\n\n        case k._do:\n          return this.parseDoStatement(n);\n\n        case k._for:\n          return this.parseForStatement(n);\n\n        case k._function:\n          return !t && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(n, !1);\n\n        case k._class:\n          return t || this.unexpected(), this.parseClass(n, !0);\n\n        case k._if:\n          return this.parseIfStatement(n);\n\n        case k._return:\n          return this.parseReturnStatement(n);\n\n        case k._switch:\n          return this.parseSwitchStatement(n);\n\n        case k._throw:\n          return this.parseThrowStatement(n);\n\n        case k._try:\n          return this.parseTryStatement(n);\n\n        case k._const:\n        case k._var:\n          return s = s || this.value, t || \"var\" === s || this.unexpected(), this.parseVarStatement(n, s);\n\n        case k._while:\n          return this.parseWhileStatement(n);\n\n        case k._with:\n          return this.parseWithStatement(n);\n\n        case k.braceL:\n          return this.parseBlock();\n\n        case k.semi:\n          return this.parseEmptyStatement(n);\n\n        case k._export:\n        case k._import:\n          return this.options.allowImportExportEverywhere || (e || this.raise(this.start, \"'import' and 'export' may only appear at the top level\"), this.inModule || this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")), r === k._import ? this.parseImport(n) : this.parseExport(n, i);\n\n        default:\n          if (this.isAsyncFunction()) return t || this.unexpected(), this.next(), this.parseFunctionStatement(n, !0);\n          var a = this.value,\n              o = this.parseExpression();\n          return r === k.name && \"Identifier\" === o.type && this.eat(k.colon) ? this.parseLabeledStatement(n, a, o) : this.parseExpressionStatement(n, o);\n      }\n    }, X.parseBreakContinueStatement = function (t, e) {\n      var i = \"break\" === e;\n      this.next(), this.eat(k.semi) || this.insertSemicolon() ? t.label = null : this.type !== k.name ? this.unexpected() : (t.label = this.parseIdent(), this.semicolon());\n\n      for (var s = 0; s < this.labels.length; ++s) {\n        var r = this.labels[s];\n\n        if (null == t.label || r.name === t.label.name) {\n          if (null != r.kind && (i || \"loop\" === r.kind)) break;\n          if (t.label && i) break;\n        }\n      }\n\n      return s === this.labels.length && this.raise(t.start, \"Unsyntactic \" + e), this.finishNode(t, i ? \"BreakStatement\" : \"ContinueStatement\");\n    }, X.parseDebuggerStatement = function (t) {\n      return this.next(), this.semicolon(), this.finishNode(t, \"DebuggerStatement\");\n    }, X.parseDoStatement = function (t) {\n      return this.next(), this.labels.push(W), t.body = this.parseStatement(!1), this.labels.pop(), this.expect(k._while), t.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(k.semi) : this.semicolon(), this.finishNode(t, \"DoWhileStatement\");\n    }, X.parseForStatement = function (t) {\n      this.next();\n      var e = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual(\"await\") ? this.lastTokStart : -1;\n      if (this.labels.push(W), this.enterLexicalScope(), this.expect(k.parenL), this.type === k.semi) return e > -1 && this.unexpected(e), this.parseFor(t, null);\n      var i = this.isLet();\n\n      if (this.type === k._var || this.type === k._const || i) {\n        var s = this.startNode(),\n            r = i ? \"let\" : this.value;\n        return this.next(), this.parseVar(s, !0, r), this.finishNode(s, \"VariableDeclaration\"), !(this.type === k._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) || 1 !== s.declarations.length || \"var\" !== r && s.declarations[0].init ? (e > -1 && this.unexpected(e), this.parseFor(t, s)) : (this.options.ecmaVersion >= 9 && (this.type === k._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.parseForIn(t, s));\n      }\n\n      var n = new G(),\n          a = this.parseExpression(!0, n);\n      return this.type === k._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\") ? (this.options.ecmaVersion >= 9 && (this.type === k._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.toAssignable(a, !1, n), this.checkLVal(a), this.parseForIn(t, a)) : (this.checkExpressionErrors(n, !0), e > -1 && this.unexpected(e), this.parseFor(t, a));\n    }, X.parseFunctionStatement = function (t, e) {\n      return this.next(), this.parseFunction(t, !0, !1, e);\n    }, X.parseIfStatement = function (t) {\n      return this.next(), t.test = this.parseParenExpression(), t.consequent = this.parseStatement(!this.strict && this.type === k._function), t.alternate = this.eat(k._else) ? this.parseStatement(!this.strict && this.type === k._function) : null, this.finishNode(t, \"IfStatement\");\n    }, X.parseReturnStatement = function (t) {\n      return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, \"'return' outside of function\"), this.next(), this.eat(k.semi) || this.insertSemicolon() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, \"ReturnStatement\");\n    }, X.parseSwitchStatement = function (t) {\n      var e;\n      this.next(), t.discriminant = this.parseParenExpression(), t.cases = [], this.expect(k.braceL), this.labels.push(H), this.enterLexicalScope();\n\n      for (var i = !1; this.type !== k.braceR;) if (this.type === k._case || this.type === k._default) {\n        var s = this.type === k._case;\n        e && this.finishNode(e, \"SwitchCase\"), t.cases.push(e = this.startNode()), e.consequent = [], this.next(), s ? e.test = this.parseExpression() : (i && this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"), i = !0, e.test = null), this.expect(k.colon);\n      } else e || this.unexpected(), e.consequent.push(this.parseStatement(!0));\n\n      return this.exitLexicalScope(), e && this.finishNode(e, \"SwitchCase\"), this.next(), this.labels.pop(), this.finishNode(t, \"SwitchStatement\");\n    }, X.parseThrowStatement = function (t) {\n      return this.next(), E.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, \"Illegal newline after throw\"), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, \"ThrowStatement\");\n    };\n    var z = [];\n    X.parseTryStatement = function (t) {\n      if (this.next(), t.block = this.parseBlock(), t.handler = null, this.type === k._catch) {\n        var e = this.startNode();\n        this.next(), this.eat(k.parenL) ? (e.param = this.parseBindingAtom(), this.enterLexicalScope(), this.checkLVal(e.param, \"let\"), this.expect(k.parenR)) : (this.options.ecmaVersion < 10 && this.unexpected(), e.param = null, this.enterLexicalScope()), e.body = this.parseBlock(!1), this.exitLexicalScope(), t.handler = this.finishNode(e, \"CatchClause\");\n      }\n\n      return t.finalizer = this.eat(k._finally) ? this.parseBlock() : null, t.handler || t.finalizer || this.raise(t.start, \"Missing catch or finally clause\"), this.finishNode(t, \"TryStatement\");\n    }, X.parseVarStatement = function (t, e) {\n      return this.next(), this.parseVar(t, !1, e), this.semicolon(), this.finishNode(t, \"VariableDeclaration\");\n    }, X.parseWhileStatement = function (t) {\n      return this.next(), t.test = this.parseParenExpression(), this.labels.push(W), t.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(t, \"WhileStatement\");\n    }, X.parseWithStatement = function (t) {\n      return this.strict && this.raise(this.start, \"'with' in strict mode\"), this.next(), t.object = this.parseParenExpression(), t.body = this.parseStatement(!1), this.finishNode(t, \"WithStatement\");\n    }, X.parseEmptyStatement = function (t) {\n      return this.next(), this.finishNode(t, \"EmptyStatement\");\n    }, X.parseLabeledStatement = function (t, e, i) {\n      for (var s = 0, r = this.labels; s < r.length; s += 1) {\n        r[s].name === e && this.raise(i.start, \"Label '\" + e + \"' is already declared\");\n      }\n\n      for (var n = this.type.isLoop ? \"loop\" : this.type === k._switch ? \"switch\" : null, a = this.labels.length - 1; a >= 0; a--) {\n        var o = this.labels[a];\n        if (o.statementStart !== t.start) break;\n        o.statementStart = this.start, o.kind = n;\n      }\n\n      return this.labels.push({\n        name: e,\n        kind: n,\n        statementStart: this.start\n      }), t.body = this.parseStatement(!0), (\"ClassDeclaration\" === t.body.type || \"VariableDeclaration\" === t.body.type && \"var\" !== t.body.kind || \"FunctionDeclaration\" === t.body.type && (this.strict || t.body.generator || t.body.async)) && this.raiseRecoverable(t.body.start, \"Invalid labeled declaration\"), this.labels.pop(), t.label = i, this.finishNode(t, \"LabeledStatement\");\n    }, X.parseExpressionStatement = function (t, e) {\n      return t.expression = e, this.semicolon(), this.finishNode(t, \"ExpressionStatement\");\n    }, X.parseBlock = function (t) {\n      void 0 === t && (t = !0);\n      var e = this.startNode();\n\n      for (e.body = [], this.expect(k.braceL), t && this.enterLexicalScope(); !this.eat(k.braceR);) {\n        var i = this.parseStatement(!0);\n        e.body.push(i);\n      }\n\n      return t && this.exitLexicalScope(), this.finishNode(e, \"BlockStatement\");\n    }, X.parseFor = function (t, e) {\n      return t.init = e, this.expect(k.semi), t.test = this.type === k.semi ? null : this.parseExpression(), this.expect(k.semi), t.update = this.type === k.parenR ? null : this.parseExpression(), this.expect(k.parenR), this.exitLexicalScope(), t.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(t, \"ForStatement\");\n    }, X.parseForIn = function (t, e) {\n      var i = this.type === k._in ? \"ForInStatement\" : \"ForOfStatement\";\n      return this.next(), \"ForInStatement\" === i && (\"AssignmentPattern\" === e.type || \"VariableDeclaration\" === e.type && null != e.declarations[0].init && (this.strict || \"Identifier\" !== e.declarations[0].id.type)) && this.raise(e.start, \"Invalid assignment in for-in loop head\"), t.left = e, t.right = \"ForInStatement\" === i ? this.parseExpression() : this.parseMaybeAssign(), this.expect(k.parenR), this.exitLexicalScope(), t.body = this.parseStatement(!1), this.labels.pop(), this.finishNode(t, i);\n    }, X.parseVar = function (t, e, i) {\n      for (t.declarations = [], t.kind = i;;) {\n        var s = this.startNode();\n        if (this.parseVarId(s, i), this.eat(k.eq) ? s.init = this.parseMaybeAssign(e) : \"const\" !== i || this.type === k._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\") ? \"Identifier\" === s.id.type || e && (this.type === k._in || this.isContextual(\"of\")) ? s.init = null : this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\") : this.unexpected(), t.declarations.push(this.finishNode(s, \"VariableDeclarator\")), !this.eat(k.comma)) break;\n      }\n\n      return t;\n    }, X.parseVarId = function (t, e) {\n      t.id = this.parseBindingAtom(e), this.checkLVal(t.id, e, !1);\n    }, X.parseFunction = function (t, e, i, s) {\n      this.initFunction(t), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !s) && (t.generator = this.eat(k.star)), this.options.ecmaVersion >= 8 && (t.async = !!s), e && (t.id = \"nullableID\" === e && this.type !== k.name ? null : this.parseIdent(), t.id && this.checkLVal(t.id, this.inModule && !this.inFunction ? \"let\" : \"var\"));\n      var r = this.inGenerator,\n          n = this.inAsync,\n          a = this.yieldPos,\n          o = this.awaitPos,\n          h = this.inFunction;\n      return this.inGenerator = t.generator, this.inAsync = t.async, this.yieldPos = 0, this.awaitPos = 0, this.inFunction = !0, this.enterFunctionScope(), e || (t.id = this.type === k.name ? this.parseIdent() : null), this.parseFunctionParams(t), this.parseFunctionBody(t, i), this.inGenerator = r, this.inAsync = n, this.yieldPos = a, this.awaitPos = o, this.inFunction = h, this.finishNode(t, e ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    }, X.parseFunctionParams = function (t) {\n      this.expect(k.parenL), t.params = this.parseBindingList(k.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();\n    }, X.parseClass = function (t, e) {\n      this.next(), this.parseClassId(t, e), this.parseClassSuper(t);\n      var i = this.startNode(),\n          s = !1;\n\n      for (i.body = [], this.expect(k.braceL); !this.eat(k.braceR);) {\n        var r = this.parseClassMember(i);\n        r && \"MethodDefinition\" === r.type && \"constructor\" === r.kind && (s && this.raise(r.start, \"Duplicate constructor in the same class\"), s = !0);\n      }\n\n      return t.body = this.finishNode(i, \"ClassBody\"), this.finishNode(t, e ? \"ClassDeclaration\" : \"ClassExpression\");\n    }, X.parseClassMember = function (t) {\n      var e = this;\n      if (this.eat(k.semi)) return null;\n\n      var i = this.startNode(),\n          s = function (t, s) {\n        void 0 === s && (s = !1);\n        var r = e.start,\n            n = e.startLoc;\n        return !!e.eatContextual(t) && (!(e.type === k.parenL || s && e.canInsertSemicolon()) || (i.key && e.unexpected(), i.computed = !1, i.key = e.startNodeAt(r, n), i.key.name = t, e.finishNode(i.key, \"Identifier\"), !1));\n      };\n\n      i.kind = \"method\", i.static = s(\"static\");\n      var r = this.eat(k.star),\n          n = !1;\n      r || (this.options.ecmaVersion >= 8 && s(\"async\", !0) ? (n = !0, r = this.options.ecmaVersion >= 9 && this.eat(k.star)) : s(\"get\") ? i.kind = \"get\" : s(\"set\") && (i.kind = \"set\")), i.key || this.parsePropertyName(i);\n      var a = i.key;\n      return i.computed || i.static || !(\"Identifier\" === a.type && \"constructor\" === a.name || \"Literal\" === a.type && \"constructor\" === a.value) ? i.static && \"Identifier\" === a.type && \"prototype\" === a.name && this.raise(a.start, \"Classes may not have a static property named prototype\") : (\"method\" !== i.kind && this.raise(a.start, \"Constructor can't have get/set modifier\"), r && this.raise(a.start, \"Constructor can't be a generator\"), n && this.raise(a.start, \"Constructor can't be an async method\"), i.kind = \"constructor\"), this.parseClassMethod(t, i, r, n), \"get\" === i.kind && 0 !== i.value.params.length && this.raiseRecoverable(i.value.start, \"getter should have no params\"), \"set\" === i.kind && 1 !== i.value.params.length && this.raiseRecoverable(i.value.start, \"setter should have exactly one param\"), \"set\" === i.kind && \"RestElement\" === i.value.params[0].type && this.raiseRecoverable(i.value.params[0].start, \"Setter cannot use rest params\"), i;\n    }, X.parseClassMethod = function (t, e, i, s) {\n      e.value = this.parseMethod(i, s), t.body.push(this.finishNode(e, \"MethodDefinition\"));\n    }, X.parseClassId = function (t, e) {\n      t.id = this.type === k.name ? this.parseIdent() : !0 === e ? this.unexpected() : null;\n    }, X.parseClassSuper = function (t) {\n      t.superClass = this.eat(k._extends) ? this.parseExprSubscripts() : null;\n    }, X.parseExport = function (t, e) {\n      if (this.next(), this.eat(k.star)) return this.expectContextual(\"from\"), this.type !== k.string && this.unexpected(), t.source = this.parseExprAtom(), this.semicolon(), this.finishNode(t, \"ExportAllDeclaration\");\n\n      if (this.eat(k._default)) {\n        var i;\n\n        if (this.checkExport(e, \"default\", this.lastTokStart), this.type === k._function || (i = this.isAsyncFunction())) {\n          var s = this.startNode();\n          this.next(), i && this.next(), t.declaration = this.parseFunction(s, \"nullableID\", !1, i);\n        } else if (this.type === k._class) {\n          var r = this.startNode();\n          t.declaration = this.parseClass(r, \"nullableID\");\n        } else t.declaration = this.parseMaybeAssign(), this.semicolon();\n\n        return this.finishNode(t, \"ExportDefaultDeclaration\");\n      }\n\n      if (this.shouldParseExportStatement()) t.declaration = this.parseStatement(!0), \"VariableDeclaration\" === t.declaration.type ? this.checkVariableExport(e, t.declaration.declarations) : this.checkExport(e, t.declaration.id.name, t.declaration.id.start), t.specifiers = [], t.source = null;else {\n        if (t.declaration = null, t.specifiers = this.parseExportSpecifiers(e), this.eatContextual(\"from\")) this.type !== k.string && this.unexpected(), t.source = this.parseExprAtom();else {\n          for (var n = 0, a = t.specifiers; n < a.length; n += 1) {\n            var o = a[n];\n            this.checkUnreserved(o.local);\n          }\n\n          t.source = null;\n        }\n        this.semicolon();\n      }\n      return this.finishNode(t, \"ExportNamedDeclaration\");\n    }, X.checkExport = function (t, e, i) {\n      t && (I(t, e) && this.raiseRecoverable(i, \"Duplicate export '\" + e + \"'\"), t[e] = !0);\n    }, X.checkPatternExport = function (t, e) {\n      var i = e.type;\n      if (\"Identifier\" === i) this.checkExport(t, e.name, e.start);else if (\"ObjectPattern\" === i) for (var s = 0, r = e.properties; s < r.length; s += 1) {\n        var n = r[s];\n        this.checkPatternExport(t, n);\n      } else if (\"ArrayPattern\" === i) for (var a = 0, o = e.elements; a < o.length; a += 1) {\n        var h = o[a];\n        h && this.checkPatternExport(t, h);\n      } else \"Property\" === i ? this.checkPatternExport(t, e.value) : \"AssignmentPattern\" === i ? this.checkPatternExport(t, e.left) : \"RestElement\" === i ? this.checkPatternExport(t, e.argument) : \"ParenthesizedExpression\" === i && this.checkPatternExport(t, e.expression);\n    }, X.checkVariableExport = function (t, e) {\n      if (t) for (var i = 0, s = e; i < s.length; i += 1) {\n        var r = s[i];\n        this.checkPatternExport(t, r.id);\n      }\n    }, X.shouldParseExportStatement = function () {\n      return \"var\" === this.type.keyword || \"const\" === this.type.keyword || \"class\" === this.type.keyword || \"function\" === this.type.keyword || this.isLet() || this.isAsyncFunction();\n    }, X.parseExportSpecifiers = function (t) {\n      var e = [],\n          i = !0;\n\n      for (this.expect(k.braceL); !this.eat(k.braceR);) {\n        if (i) i = !1;else if (this.expect(k.comma), this.afterTrailingComma(k.braceR)) break;\n        var s = this.startNode();\n        s.local = this.parseIdent(!0), s.exported = this.eatContextual(\"as\") ? this.parseIdent(!0) : s.local, this.checkExport(t, s.exported.name, s.exported.start), e.push(this.finishNode(s, \"ExportSpecifier\"));\n      }\n\n      return e;\n    }, X.parseImport = function (t) {\n      return this.next(), this.type === k.string ? (t.specifiers = z, t.source = this.parseExprAtom()) : (t.specifiers = this.parseImportSpecifiers(), this.expectContextual(\"from\"), t.source = this.type === k.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(t, \"ImportDeclaration\");\n    }, X.parseImportSpecifiers = function () {\n      var t = [],\n          e = !0;\n\n      if (this.type === k.name) {\n        var i = this.startNode();\n        if (i.local = this.parseIdent(), this.checkLVal(i.local, \"let\"), t.push(this.finishNode(i, \"ImportDefaultSpecifier\")), !this.eat(k.comma)) return t;\n      }\n\n      if (this.type === k.star) {\n        var s = this.startNode();\n        return this.next(), this.expectContextual(\"as\"), s.local = this.parseIdent(), this.checkLVal(s.local, \"let\"), t.push(this.finishNode(s, \"ImportNamespaceSpecifier\")), t;\n      }\n\n      for (this.expect(k.braceL); !this.eat(k.braceR);) {\n        if (e) e = !1;else if (this.expect(k.comma), this.afterTrailingComma(k.braceR)) break;\n        var r = this.startNode();\n        r.imported = this.parseIdent(!0), this.eatContextual(\"as\") ? r.local = this.parseIdent() : (this.checkUnreserved(r.imported), r.local = r.imported), this.checkLVal(r.local, \"let\"), t.push(this.finishNode(r, \"ImportSpecifier\"));\n      }\n\n      return t;\n    }, X.adaptDirectivePrologue = function (t) {\n      for (var e = 0; e < t.length && this.isDirectiveCandidate(t[e]); ++e) t[e].directive = t[e].expression.raw.slice(1, -1);\n    }, X.isDirectiveCandidate = function (t) {\n      return \"ExpressionStatement\" === t.type && \"Literal\" === t.expression.type && \"string\" == typeof t.expression.value && ('\"' === this.input[t.start] || \"'\" === this.input[t.start]);\n    };\n    var J = F.prototype;\n    J.toAssignable = function (t, e, i) {\n      if (this.options.ecmaVersion >= 6 && t) switch (t.type) {\n        case \"Identifier\":\n          this.inAsync && \"await\" === t.name && this.raise(t.start, \"Can not use 'await' as identifier inside an async function\");\n          break;\n\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n        case \"RestElement\":\n          break;\n\n        case \"ObjectExpression\":\n          t.type = \"ObjectPattern\", i && this.checkPatternErrors(i, !0);\n\n          for (var s = 0, r = t.properties; s < r.length; s += 1) {\n            var n = r[s];\n            this.toAssignable(n, e), \"RestElement\" !== n.type || \"ArrayPattern\" !== n.argument.type && \"ObjectPattern\" !== n.argument.type || this.raise(n.argument.start, \"Unexpected token\");\n          }\n\n          break;\n\n        case \"Property\":\n          \"init\" !== t.kind && this.raise(t.key.start, \"Object pattern can't contain getter or setter\"), this.toAssignable(t.value, e);\n          break;\n\n        case \"ArrayExpression\":\n          t.type = \"ArrayPattern\", i && this.checkPatternErrors(i, !0), this.toAssignableList(t.elements, e);\n          break;\n\n        case \"SpreadElement\":\n          t.type = \"RestElement\", this.toAssignable(t.argument, e), \"AssignmentPattern\" === t.argument.type && this.raise(t.argument.start, \"Rest elements cannot have a default value\");\n          break;\n\n        case \"AssignmentExpression\":\n          \"=\" !== t.operator && this.raise(t.left.end, \"Only '=' operator can be used for specifying default value.\"), t.type = \"AssignmentPattern\", delete t.operator, this.toAssignable(t.left, e);\n\n        case \"AssignmentPattern\":\n          break;\n\n        case \"ParenthesizedExpression\":\n          this.toAssignable(t.expression, e);\n          break;\n\n        case \"MemberExpression\":\n          if (!e) break;\n\n        default:\n          this.raise(t.start, \"Assigning to rvalue\");\n      } else i && this.checkPatternErrors(i, !0);\n      return t;\n    }, J.toAssignableList = function (t, e) {\n      for (var i = t.length, s = 0; s < i; s++) {\n        var r = t[s];\n        r && this.toAssignable(r, e);\n      }\n\n      if (i) {\n        var n = t[i - 1];\n        6 === this.options.ecmaVersion && e && n && \"RestElement\" === n.type && \"Identifier\" !== n.argument.type && this.unexpected(n.argument.start);\n      }\n\n      return t;\n    }, J.parseSpread = function (t) {\n      var e = this.startNode();\n      return this.next(), e.argument = this.parseMaybeAssign(!1, t), this.finishNode(e, \"SpreadElement\");\n    }, J.parseRestBinding = function () {\n      var t = this.startNode();\n      return this.next(), 6 === this.options.ecmaVersion && this.type !== k.name && this.unexpected(), t.argument = this.parseBindingAtom(), this.finishNode(t, \"RestElement\");\n    }, J.parseBindingAtom = function () {\n      if (this.options.ecmaVersion >= 6) switch (this.type) {\n        case k.bracketL:\n          var t = this.startNode();\n          return this.next(), t.elements = this.parseBindingList(k.bracketR, !0, !0), this.finishNode(t, \"ArrayPattern\");\n\n        case k.braceL:\n          return this.parseObj(!0);\n      }\n      return this.parseIdent();\n    }, J.parseBindingList = function (t, e, i) {\n      for (var s = [], r = !0; !this.eat(t);) if (r ? r = !1 : this.expect(k.comma), e && this.type === k.comma) s.push(null);else {\n        if (i && this.afterTrailingComma(t)) break;\n\n        if (this.type === k.ellipsis) {\n          var n = this.parseRestBinding();\n          this.parseBindingListItem(n), s.push(n), this.type === k.comma && this.raise(this.start, \"Comma is not permitted after the rest element\"), this.expect(t);\n          break;\n        }\n\n        var a = this.parseMaybeDefault(this.start, this.startLoc);\n        this.parseBindingListItem(a), s.push(a);\n      }\n\n      return s;\n    }, J.parseBindingListItem = function (t) {\n      return t;\n    }, J.parseMaybeDefault = function (t, e, i) {\n      if (i = i || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(k.eq)) return i;\n      var s = this.startNodeAt(t, e);\n      return s.left = i, s.right = this.parseMaybeAssign(), this.finishNode(s, \"AssignmentPattern\");\n    }, J.checkLVal = function (t, e, i) {\n      switch (t.type) {\n        case \"Identifier\":\n          this.strict && this.reservedWordsStrictBind.test(t.name) && this.raiseRecoverable(t.start, (e ? \"Binding \" : \"Assigning to \") + t.name + \" in strict mode\"), i && (I(i, t.name) && this.raiseRecoverable(t.start, \"Argument name clash\"), i[t.name] = !0), e && \"none\" !== e && ((\"var\" === e && !this.canDeclareVarName(t.name) || \"var\" !== e && !this.canDeclareLexicalName(t.name)) && this.raiseRecoverable(t.start, \"Identifier '\" + t.name + \"' has already been declared\"), \"var\" === e ? this.declareVarName(t.name) : this.declareLexicalName(t.name));\n          break;\n\n        case \"MemberExpression\":\n          e && this.raiseRecoverable(t.start, \"Binding member expression\");\n          break;\n\n        case \"ObjectPattern\":\n          for (var s = 0, r = t.properties; s < r.length; s += 1) {\n            var n = r[s];\n            this.checkLVal(n, e, i);\n          }\n\n          break;\n\n        case \"Property\":\n          this.checkLVal(t.value, e, i);\n          break;\n\n        case \"ArrayPattern\":\n          for (var a = 0, o = t.elements; a < o.length; a += 1) {\n            var h = o[a];\n            h && this.checkLVal(h, e, i);\n          }\n\n          break;\n\n        case \"AssignmentPattern\":\n          this.checkLVal(t.left, e, i);\n          break;\n\n        case \"RestElement\":\n          this.checkLVal(t.argument, e, i);\n          break;\n\n        case \"ParenthesizedExpression\":\n          this.checkLVal(t.expression, e, i);\n          break;\n\n        default:\n          this.raise(t.start, (e ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n      }\n    };\n    var Q = F.prototype;\n    Q.checkPropClash = function (t, e, i) {\n      if (!(this.options.ecmaVersion >= 9 && \"SpreadElement\" === t.type || this.options.ecmaVersion >= 6 && (t.computed || t.method || t.shorthand))) {\n        var s,\n            r = t.key;\n\n        switch (r.type) {\n          case \"Identifier\":\n            s = r.name;\n            break;\n\n          case \"Literal\":\n            s = String(r.value);\n            break;\n\n          default:\n            return;\n        }\n\n        var n = t.kind;\n        if (this.options.ecmaVersion >= 6) \"__proto__\" === s && \"init\" === n && (e.proto && (i && i.doubleProto < 0 ? i.doubleProto = r.start : this.raiseRecoverable(r.start, \"Redefinition of __proto__ property\")), e.proto = !0);else {\n          var a = e[s = \"$\" + s];\n          if (a) (\"init\" === n ? this.strict && a.init || a.get || a.set : a.init || a[n]) && this.raiseRecoverable(r.start, \"Redefinition of property\");else a = e[s] = {\n            init: !1,\n            get: !1,\n            set: !1\n          };\n          a[n] = !0;\n        }\n      }\n    }, Q.parseExpression = function (t, e) {\n      var i = this.start,\n          s = this.startLoc,\n          r = this.parseMaybeAssign(t, e);\n\n      if (this.type === k.comma) {\n        var n = this.startNodeAt(i, s);\n\n        for (n.expressions = [r]; this.eat(k.comma);) n.expressions.push(this.parseMaybeAssign(t, e));\n\n        return this.finishNode(n, \"SequenceExpression\");\n      }\n\n      return r;\n    }, Q.parseMaybeAssign = function (t, e, i) {\n      if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield();\n      var s = !1,\n          r = -1,\n          n = -1;\n      e ? (r = e.parenthesizedAssign, n = e.trailingComma, e.parenthesizedAssign = e.trailingComma = -1) : (e = new G(), s = !0);\n      var a = this.start,\n          o = this.startLoc;\n      this.type !== k.parenL && this.type !== k.name || (this.potentialArrowAt = this.start);\n      var h = this.parseMaybeConditional(t, e);\n\n      if (i && (h = i.call(this, h, a, o)), this.type.isAssign) {\n        var p = this.startNodeAt(a, o);\n        return p.operator = this.value, p.left = this.type === k.eq ? this.toAssignable(h, !1, e) : h, s || G.call(e), e.shorthandAssign = -1, this.checkLVal(h), this.next(), p.right = this.parseMaybeAssign(t), this.finishNode(p, \"AssignmentExpression\");\n      }\n\n      return s && this.checkExpressionErrors(e, !0), r > -1 && (e.parenthesizedAssign = r), n > -1 && (e.trailingComma = n), h;\n    }, Q.parseMaybeConditional = function (t, e) {\n      var i = this.start,\n          s = this.startLoc,\n          r = this.parseExprOps(t, e);\n      if (this.checkExpressionErrors(e)) return r;\n\n      if (this.eat(k.question)) {\n        var n = this.startNodeAt(i, s);\n        return n.test = r, n.consequent = this.parseMaybeAssign(), this.expect(k.colon), n.alternate = this.parseMaybeAssign(t), this.finishNode(n, \"ConditionalExpression\");\n      }\n\n      return r;\n    }, Q.parseExprOps = function (t, e) {\n      var i = this.start,\n          s = this.startLoc,\n          r = this.parseMaybeUnary(e, !1);\n      return this.checkExpressionErrors(e) ? r : r.start === i && \"ArrowFunctionExpression\" === r.type ? r : this.parseExprOp(r, i, s, -1, t);\n    }, Q.parseExprOp = function (t, e, i, s, r) {\n      var n = this.type.binop;\n\n      if (null != n && (!r || this.type !== k._in) && n > s) {\n        var a = this.type === k.logicalOR || this.type === k.logicalAND,\n            o = this.value;\n        this.next();\n        var h = this.start,\n            p = this.startLoc,\n            c = this.parseExprOp(this.parseMaybeUnary(null, !1), h, p, n, r),\n            u = this.buildBinary(e, i, t, c, o, a);\n        return this.parseExprOp(u, e, i, s, r);\n      }\n\n      return t;\n    }, Q.buildBinary = function (t, e, i, s, r, n) {\n      var a = this.startNodeAt(t, e);\n      return a.left = i, a.operator = r, a.right = s, this.finishNode(a, n ? \"LogicalExpression\" : \"BinaryExpression\");\n    }, Q.parseMaybeUnary = function (t, e) {\n      var i,\n          s = this.start,\n          r = this.startLoc;\n      if (this.isContextual(\"await\") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) i = this.parseAwait(), e = !0;else if (this.type.prefix) {\n        var n = this.startNode(),\n            a = this.type === k.incDec;\n        n.operator = this.value, n.prefix = !0, this.next(), n.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), a ? this.checkLVal(n.argument) : this.strict && \"delete\" === n.operator && \"Identifier\" === n.argument.type ? this.raiseRecoverable(n.start, \"Deleting local variable in strict mode\") : e = !0, i = this.finishNode(n, a ? \"UpdateExpression\" : \"UnaryExpression\");\n      } else {\n        if (i = this.parseExprSubscripts(t), this.checkExpressionErrors(t)) return i;\n\n        for (; this.type.postfix && !this.canInsertSemicolon();) {\n          var o = this.startNodeAt(s, r);\n          o.operator = this.value, o.prefix = !1, o.argument = i, this.checkLVal(i), this.next(), i = this.finishNode(o, \"UpdateExpression\");\n        }\n      }\n      return !e && this.eat(k.starstar) ? this.buildBinary(s, r, i, this.parseMaybeUnary(null, !1), \"**\", !1) : i;\n    }, Q.parseExprSubscripts = function (t) {\n      var e = this.start,\n          i = this.startLoc,\n          s = this.parseExprAtom(t),\n          r = \"ArrowFunctionExpression\" === s.type && \")\" !== this.input.slice(this.lastTokStart, this.lastTokEnd);\n      if (this.checkExpressionErrors(t) || r) return s;\n      var n = this.parseSubscripts(s, e, i);\n      return t && \"MemberExpression\" === n.type && (t.parenthesizedAssign >= n.start && (t.parenthesizedAssign = -1), t.parenthesizedBind >= n.start && (t.parenthesizedBind = -1)), n;\n    }, Q.parseSubscripts = function (t, e, i, s) {\n      for (var r = this.options.ecmaVersion >= 8 && \"Identifier\" === t.type && \"async\" === t.name && this.lastTokEnd === t.end && !this.canInsertSemicolon() && \"async\" === this.input.slice(t.start, t.end), n = void 0;;) if ((n = this.eat(k.bracketL)) || this.eat(k.dot)) {\n        var a = this.startNodeAt(e, i);\n        a.object = t, a.property = n ? this.parseExpression() : this.parseIdent(!0), a.computed = !!n, n && this.expect(k.bracketR), t = this.finishNode(a, \"MemberExpression\");\n      } else if (!s && this.eat(k.parenL)) {\n        var o = new G(),\n            h = this.yieldPos,\n            p = this.awaitPos;\n        this.yieldPos = 0, this.awaitPos = 0;\n        var c = this.parseExprList(k.parenR, this.options.ecmaVersion >= 8, !1, o);\n        if (r && !this.canInsertSemicolon() && this.eat(k.arrow)) return this.checkPatternErrors(o, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = h, this.awaitPos = p, this.parseArrowExpression(this.startNodeAt(e, i), c, !0);\n        this.checkExpressionErrors(o, !0), this.yieldPos = h || this.yieldPos, this.awaitPos = p || this.awaitPos;\n        var u = this.startNodeAt(e, i);\n        u.callee = t, u.arguments = c, t = this.finishNode(u, \"CallExpression\");\n      } else {\n        if (this.type !== k.backQuote) return t;\n        var l = this.startNodeAt(e, i);\n        l.tag = t, l.quasi = this.parseTemplate({\n          isTagged: !0\n        }), t = this.finishNode(l, \"TaggedTemplateExpression\");\n      }\n    }, Q.parseExprAtom = function (t) {\n      var e,\n          i = this.potentialArrowAt === this.start;\n\n      switch (this.type) {\n        case k._super:\n          return this.inFunction || this.raise(this.start, \"'super' outside of function or class\"), e = this.startNode(), this.next(), this.type !== k.dot && this.type !== k.bracketL && this.type !== k.parenL && this.unexpected(), this.finishNode(e, \"Super\");\n\n        case k._this:\n          return e = this.startNode(), this.next(), this.finishNode(e, \"ThisExpression\");\n\n        case k.name:\n          var s = this.start,\n              r = this.startLoc,\n              n = this.containsEsc,\n              a = this.parseIdent(this.type !== k.name);\n          if (this.options.ecmaVersion >= 8 && !n && \"async\" === a.name && !this.canInsertSemicolon() && this.eat(k._function)) return this.parseFunction(this.startNodeAt(s, r), !1, !1, !0);\n\n          if (i && !this.canInsertSemicolon()) {\n            if (this.eat(k.arrow)) return this.parseArrowExpression(this.startNodeAt(s, r), [a], !1);\n            if (this.options.ecmaVersion >= 8 && \"async\" === a.name && this.type === k.name && !n) return a = this.parseIdent(), !this.canInsertSemicolon() && this.eat(k.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(s, r), [a], !0);\n          }\n\n          return a;\n\n        case k.regexp:\n          var o = this.value;\n          return (e = this.parseLiteral(o.value)).regex = {\n            pattern: o.pattern,\n            flags: o.flags\n          }, e;\n\n        case k.num:\n        case k.string:\n          return this.parseLiteral(this.value);\n\n        case k._null:\n        case k._true:\n        case k._false:\n          return (e = this.startNode()).value = this.type === k._null ? null : this.type === k._true, e.raw = this.type.keyword, this.next(), this.finishNode(e, \"Literal\");\n\n        case k.parenL:\n          var h = this.start,\n              p = this.parseParenAndDistinguishExpression(i);\n          return t && (t.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(p) && (t.parenthesizedAssign = h), t.parenthesizedBind < 0 && (t.parenthesizedBind = h)), p;\n\n        case k.bracketL:\n          return e = this.startNode(), this.next(), e.elements = this.parseExprList(k.bracketR, !0, !0, t), this.finishNode(e, \"ArrayExpression\");\n\n        case k.braceL:\n          return this.parseObj(!1, t);\n\n        case k._function:\n          return e = this.startNode(), this.next(), this.parseFunction(e, !1);\n\n        case k._class:\n          return this.parseClass(this.startNode(), !1);\n\n        case k._new:\n          return this.parseNew();\n\n        case k.backQuote:\n          return this.parseTemplate();\n\n        default:\n          this.unexpected();\n      }\n    }, Q.parseLiteral = function (t) {\n      var e = this.startNode();\n      return e.value = t, e.raw = this.input.slice(this.start, this.end), this.next(), this.finishNode(e, \"Literal\");\n    }, Q.parseParenExpression = function () {\n      this.expect(k.parenL);\n      var t = this.parseExpression();\n      return this.expect(k.parenR), t;\n    }, Q.parseParenAndDistinguishExpression = function (t) {\n      var e,\n          i = this.start,\n          s = this.startLoc,\n          r = this.options.ecmaVersion >= 8;\n\n      if (this.options.ecmaVersion >= 6) {\n        this.next();\n        var n,\n            a = this.start,\n            o = this.startLoc,\n            h = [],\n            p = !0,\n            c = !1,\n            u = new G(),\n            l = this.yieldPos,\n            d = this.awaitPos;\n\n        for (this.yieldPos = 0, this.awaitPos = 0; this.type !== k.parenR;) {\n          if (p ? p = !1 : this.expect(k.comma), r && this.afterTrailingComma(k.parenR, !0)) {\n            c = !0;\n            break;\n          }\n\n          if (this.type === k.ellipsis) {\n            n = this.start, h.push(this.parseParenItem(this.parseRestBinding())), this.type === k.comma && this.raise(this.start, \"Comma is not permitted after the rest element\");\n            break;\n          }\n\n          h.push(this.parseMaybeAssign(!1, u, this.parseParenItem));\n        }\n\n        var f = this.start,\n            m = this.startLoc;\n        if (this.expect(k.parenR), t && !this.canInsertSemicolon() && this.eat(k.arrow)) return this.checkPatternErrors(u, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = l, this.awaitPos = d, this.parseParenArrowList(i, s, h);\n        h.length && !c || this.unexpected(this.lastTokStart), n && this.unexpected(n), this.checkExpressionErrors(u, !0), this.yieldPos = l || this.yieldPos, this.awaitPos = d || this.awaitPos, h.length > 1 ? ((e = this.startNodeAt(a, o)).expressions = h, this.finishNodeAt(e, \"SequenceExpression\", f, m)) : e = h[0];\n      } else e = this.parseParenExpression();\n\n      if (this.options.preserveParens) {\n        var x = this.startNodeAt(i, s);\n        return x.expression = e, this.finishNode(x, \"ParenthesizedExpression\");\n      }\n\n      return e;\n    }, Q.parseParenItem = function (t) {\n      return t;\n    }, Q.parseParenArrowList = function (t, e, i) {\n      return this.parseArrowExpression(this.startNodeAt(t, e), i);\n    };\n    var K = [];\n    Q.parseNew = function () {\n      var t = this.startNode(),\n          e = this.parseIdent(!0);\n\n      if (this.options.ecmaVersion >= 6 && this.eat(k.dot)) {\n        t.meta = e;\n        var i = this.containsEsc;\n        return t.property = this.parseIdent(!0), (\"target\" !== t.property.name || i) && this.raiseRecoverable(t.property.start, \"The only valid meta property for new is new.target\"), this.inFunction || this.raiseRecoverable(t.start, \"new.target can only be used in functions\"), this.finishNode(t, \"MetaProperty\");\n      }\n\n      var s = this.start,\n          r = this.startLoc;\n      return t.callee = this.parseSubscripts(this.parseExprAtom(), s, r, !0), this.eat(k.parenL) ? t.arguments = this.parseExprList(k.parenR, this.options.ecmaVersion >= 8, !1) : t.arguments = K, this.finishNode(t, \"NewExpression\");\n    }, Q.parseTemplateElement = function (t) {\n      var e = t.isTagged,\n          i = this.startNode();\n      return this.type === k.invalidTemplate ? (e || this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\"), i.value = {\n        raw: this.value,\n        cooked: null\n      }) : i.value = {\n        raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.value\n      }, this.next(), i.tail = this.type === k.backQuote, this.finishNode(i, \"TemplateElement\");\n    }, Q.parseTemplate = function (t) {\n      void 0 === t && (t = {});\n      var e = t.isTagged;\n      void 0 === e && (e = !1);\n      var i = this.startNode();\n      this.next(), i.expressions = [];\n      var s = this.parseTemplateElement({\n        isTagged: e\n      });\n\n      for (i.quasis = [s]; !s.tail;) this.type === k.eof && this.raise(this.pos, \"Unterminated template literal\"), this.expect(k.dollarBraceL), i.expressions.push(this.parseExpression()), this.expect(k.braceR), i.quasis.push(s = this.parseTemplateElement({\n        isTagged: e\n      }));\n\n      return this.next(), this.finishNode(i, \"TemplateLiteral\");\n    }, Q.isAsyncProp = function (t) {\n      return !t.computed && \"Identifier\" === t.key.type && \"async\" === t.key.name && (this.type === k.name || this.type === k.num || this.type === k.string || this.type === k.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === k.star) && !E.test(this.input.slice(this.lastTokEnd, this.start));\n    }, Q.parseObj = function (t, e) {\n      var i = this.startNode(),\n          s = !0,\n          r = {};\n\n      for (i.properties = [], this.next(); !this.eat(k.braceR);) {\n        if (s) s = !1;else if (this.expect(k.comma), this.afterTrailingComma(k.braceR)) break;\n        var n = this.parseProperty(t, e);\n        t || this.checkPropClash(n, r, e), i.properties.push(n);\n      }\n\n      return this.finishNode(i, t ? \"ObjectPattern\" : \"ObjectExpression\");\n    }, Q.parseProperty = function (t, e) {\n      var i,\n          s,\n          r,\n          n,\n          a = this.startNode();\n      if (this.options.ecmaVersion >= 9 && this.eat(k.ellipsis)) return t ? (a.argument = this.parseIdent(!1), this.type === k.comma && this.raise(this.start, \"Comma is not permitted after the rest element\"), this.finishNode(a, \"RestElement\")) : (this.type === k.parenL && e && (e.parenthesizedAssign < 0 && (e.parenthesizedAssign = this.start), e.parenthesizedBind < 0 && (e.parenthesizedBind = this.start)), a.argument = this.parseMaybeAssign(!1, e), this.type === k.comma && e && e.trailingComma < 0 && (e.trailingComma = this.start), this.finishNode(a, \"SpreadElement\"));\n      this.options.ecmaVersion >= 6 && (a.method = !1, a.shorthand = !1, (t || e) && (r = this.start, n = this.startLoc), t || (i = this.eat(k.star)));\n      var o = this.containsEsc;\n      return this.parsePropertyName(a), !t && !o && this.options.ecmaVersion >= 8 && !i && this.isAsyncProp(a) ? (s = !0, i = this.options.ecmaVersion >= 9 && this.eat(k.star), this.parsePropertyName(a, e)) : s = !1, this.parsePropertyValue(a, t, i, s, r, n, e, o), this.finishNode(a, \"Property\");\n    }, Q.parsePropertyValue = function (t, e, i, s, r, n, a, o) {\n      if ((i || s) && this.type === k.colon && this.unexpected(), this.eat(k.colon)) t.value = e ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, a), t.kind = \"init\";else if (this.options.ecmaVersion >= 6 && this.type === k.parenL) e && this.unexpected(), t.kind = \"init\", t.method = !0, t.value = this.parseMethod(i, s);else if (e || o || !(this.options.ecmaVersion >= 5) || t.computed || \"Identifier\" !== t.key.type || \"get\" !== t.key.name && \"set\" !== t.key.name || this.type === k.comma || this.type === k.braceR) this.options.ecmaVersion >= 6 && !t.computed && \"Identifier\" === t.key.type ? (this.checkUnreserved(t.key), t.kind = \"init\", e ? t.value = this.parseMaybeDefault(r, n, t.key) : this.type === k.eq && a ? (a.shorthandAssign < 0 && (a.shorthandAssign = this.start), t.value = this.parseMaybeDefault(r, n, t.key)) : t.value = t.key, t.shorthand = !0) : this.unexpected();else {\n        (i || s) && this.unexpected(), t.kind = t.key.name, this.parsePropertyName(t), t.value = this.parseMethod(!1);\n        var h = \"get\" === t.kind ? 0 : 1;\n\n        if (t.value.params.length !== h) {\n          var p = t.value.start;\n          \"get\" === t.kind ? this.raiseRecoverable(p, \"getter should have no params\") : this.raiseRecoverable(p, \"setter should have exactly one param\");\n        } else \"set\" === t.kind && \"RestElement\" === t.value.params[0].type && this.raiseRecoverable(t.value.params[0].start, \"Setter cannot use rest params\");\n      }\n    }, Q.parsePropertyName = function (t) {\n      if (this.options.ecmaVersion >= 6) {\n        if (this.eat(k.bracketL)) return t.computed = !0, t.key = this.parseMaybeAssign(), this.expect(k.bracketR), t.key;\n        t.computed = !1;\n      }\n\n      return t.key = this.type === k.num || this.type === k.string ? this.parseExprAtom() : this.parseIdent(!0);\n    }, Q.initFunction = function (t) {\n      t.id = null, this.options.ecmaVersion >= 6 && (t.generator = !1, t.expression = !1), this.options.ecmaVersion >= 8 && (t.async = !1);\n    }, Q.parseMethod = function (t, e) {\n      var i = this.startNode(),\n          s = this.inGenerator,\n          r = this.inAsync,\n          n = this.yieldPos,\n          a = this.awaitPos,\n          o = this.inFunction;\n      return this.initFunction(i), this.options.ecmaVersion >= 6 && (i.generator = t), this.options.ecmaVersion >= 8 && (i.async = !!e), this.inGenerator = i.generator, this.inAsync = i.async, this.yieldPos = 0, this.awaitPos = 0, this.inFunction = !0, this.enterFunctionScope(), this.expect(k.parenL), i.params = this.parseBindingList(k.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(i, !1), this.inGenerator = s, this.inAsync = r, this.yieldPos = n, this.awaitPos = a, this.inFunction = o, this.finishNode(i, \"FunctionExpression\");\n    }, Q.parseArrowExpression = function (t, e, i) {\n      var s = this.inGenerator,\n          r = this.inAsync,\n          n = this.yieldPos,\n          a = this.awaitPos,\n          o = this.inFunction;\n      return this.enterFunctionScope(), this.initFunction(t), this.options.ecmaVersion >= 8 && (t.async = !!i), this.inGenerator = !1, this.inAsync = t.async, this.yieldPos = 0, this.awaitPos = 0, this.inFunction = !0, t.params = this.toAssignableList(e, !0), this.parseFunctionBody(t, !0), this.inGenerator = s, this.inAsync = r, this.yieldPos = n, this.awaitPos = a, this.inFunction = o, this.finishNode(t, \"ArrowFunctionExpression\");\n    }, Q.parseFunctionBody = function (t, e) {\n      var i = e && this.type !== k.braceL,\n          s = this.strict,\n          r = !1;\n      if (i) t.body = this.parseMaybeAssign(), t.expression = !0, this.checkParams(t, !1);else {\n        var n = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(t.params);\n        s && !n || (r = this.strictDirective(this.end)) && n && this.raiseRecoverable(t.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n        var a = this.labels;\n        this.labels = [], r && (this.strict = !0), this.checkParams(t, !s && !r && !e && this.isSimpleParamList(t.params)), t.body = this.parseBlock(!1), t.expression = !1, this.adaptDirectivePrologue(t.body.body), this.labels = a;\n      }\n      this.exitFunctionScope(), this.strict && t.id && this.checkLVal(t.id, \"none\"), this.strict = s;\n    }, Q.isSimpleParamList = function (t) {\n      for (var e = 0, i = t; e < i.length; e += 1) {\n        if (\"Identifier\" !== i[e].type) return !1;\n      }\n\n      return !0;\n    }, Q.checkParams = function (t, e) {\n      for (var i = {}, s = 0, r = t.params; s < r.length; s += 1) {\n        var n = r[s];\n        this.checkLVal(n, \"var\", e ? null : i);\n      }\n    }, Q.parseExprList = function (t, e, i, s) {\n      for (var r = [], n = !0; !this.eat(t);) {\n        if (n) n = !1;else if (this.expect(k.comma), e && this.afterTrailingComma(t)) break;\n        var a = void 0;\n        i && this.type === k.comma ? a = null : this.type === k.ellipsis ? (a = this.parseSpread(s), s && this.type === k.comma && s.trailingComma < 0 && (s.trailingComma = this.start)) : a = this.parseMaybeAssign(!1, s), r.push(a);\n      }\n\n      return r;\n    }, Q.checkUnreserved = function (t) {\n      var e = t.start,\n          i = t.end,\n          s = t.name;\n      (this.inGenerator && \"yield\" === s && this.raiseRecoverable(e, \"Can not use 'yield' as identifier inside a generator\"), this.inAsync && \"await\" === s && this.raiseRecoverable(e, \"Can not use 'await' as identifier inside an async function\"), this.isKeyword(s) && this.raise(e, \"Unexpected keyword '\" + s + \"'\"), this.options.ecmaVersion < 6 && -1 !== this.input.slice(e, i).indexOf(\"\\\\\")) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(s) && (this.inAsync || \"await\" !== s || this.raiseRecoverable(e, \"Can not use keyword 'await' outside an async function\"), this.raiseRecoverable(e, \"The keyword '\" + s + \"' is reserved\"));\n    }, Q.parseIdent = function (t, e) {\n      var i = this.startNode();\n      return t && \"never\" === this.options.allowReserved && (t = !1), this.type === k.name ? i.name = this.value : this.type.keyword ? (i.name = this.type.keyword, \"class\" !== i.name && \"function\" !== i.name || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || this.context.pop()) : this.unexpected(), this.next(), this.finishNode(i, \"Identifier\"), t || this.checkUnreserved(i), i;\n    }, Q.parseYield = function () {\n      this.yieldPos || (this.yieldPos = this.start);\n      var t = this.startNode();\n      return this.next(), this.type === k.semi || this.canInsertSemicolon() || this.type !== k.star && !this.type.startsExpr ? (t.delegate = !1, t.argument = null) : (t.delegate = this.eat(k.star), t.argument = this.parseMaybeAssign()), this.finishNode(t, \"YieldExpression\");\n    }, Q.parseAwait = function () {\n      this.awaitPos || (this.awaitPos = this.start);\n      var t = this.startNode();\n      return this.next(), t.argument = this.parseMaybeUnary(null, !0), this.finishNode(t, \"AwaitExpression\");\n    };\n    var $ = F.prototype;\n    $.raise = function (t, e) {\n      var i = O(this.input, t);\n      e += \" (\" + i.line + \":\" + i.column + \")\";\n      var s = new SyntaxError(e);\n      throw s.pos = t, s.loc = i, s.raisedAt = this.pos, s;\n    }, $.raiseRecoverable = $.raise, $.curPosition = function () {\n      if (this.options.locations) return new V(this.curLine, this.pos - this.lineStart);\n    };\n\n    var Z = F.prototype,\n        Y = Object.assign || function (t) {\n      for (var e = [], i = arguments.length - 1; i-- > 0;) e[i] = arguments[i + 1];\n\n      for (var s = 0, r = e; s < r.length; s += 1) {\n        var n = r[s];\n\n        for (var a in n) I(n, a) && (t[a] = n[a]);\n      }\n\n      return t;\n    };\n\n    Z.enterFunctionScope = function () {\n      this.scopeStack.push({\n        var: {},\n        lexical: {},\n        childVar: {},\n        parentLexical: {}\n      });\n    }, Z.exitFunctionScope = function () {\n      this.scopeStack.pop();\n    }, Z.enterLexicalScope = function () {\n      var t = this.scopeStack[this.scopeStack.length - 1],\n          e = {\n        var: {},\n        lexical: {},\n        childVar: {},\n        parentLexical: {}\n      };\n      this.scopeStack.push(e), Y(e.parentLexical, t.lexical, t.parentLexical);\n    }, Z.exitLexicalScope = function () {\n      var t = this.scopeStack.pop(),\n          e = this.scopeStack[this.scopeStack.length - 1];\n      Y(e.childVar, t.var, t.childVar);\n    }, Z.canDeclareVarName = function (t) {\n      var e = this.scopeStack[this.scopeStack.length - 1];\n      return !I(e.lexical, t) && !I(e.parentLexical, t);\n    }, Z.canDeclareLexicalName = function (t) {\n      var e = this.scopeStack[this.scopeStack.length - 1];\n      return !I(e.lexical, t) && !I(e.var, t) && !I(e.childVar, t);\n    }, Z.declareVarName = function (t) {\n      this.scopeStack[this.scopeStack.length - 1].var[t] = !0;\n    }, Z.declareLexicalName = function (t) {\n      this.scopeStack[this.scopeStack.length - 1].lexical[t] = !0;\n    };\n\n    var tt = function (t, e, i) {\n      this.type = \"\", this.start = e, this.end = 0, t.options.locations && (this.loc = new j(t, i)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [e, 0]);\n    },\n        et = F.prototype;\n\n    function it(t, e, i, s) {\n      return t.type = e, t.end = i, this.options.locations && (t.loc.end = s), this.options.ranges && (t.range[1] = i), t;\n    }\n\n    et.startNode = function () {\n      return new tt(this, this.start, this.startLoc);\n    }, et.startNodeAt = function (t, e) {\n      return new tt(this, t, e);\n    }, et.finishNode = function (t, e) {\n      return it.call(this, t, e, this.lastTokEnd, this.lastTokEndLoc);\n    }, et.finishNodeAt = function (t, e, i, s) {\n      return it.call(this, t, e, i, s);\n    };\n\n    var st = function (t, e, i, s, r) {\n      this.token = t, this.isExpr = !!e, this.preserveSpace = !!i, this.override = s, this.generator = !!r;\n    },\n        rt = {\n      b_stat: new st(\"{\", !1),\n      b_expr: new st(\"{\", !0),\n      b_tmpl: new st(\"${\", !1),\n      p_stat: new st(\"(\", !1),\n      p_expr: new st(\"(\", !0),\n      q_tmpl: new st(\"`\", !0, !0, function (t) {\n        return t.tryReadTemplateToken();\n      }),\n      f_stat: new st(\"function\", !1),\n      f_expr: new st(\"function\", !0),\n      f_expr_gen: new st(\"function\", !0, !1, null, !0),\n      f_gen: new st(\"function\", !1, !1, null, !0)\n    },\n        nt = F.prototype;\n\n    nt.initialContext = function () {\n      return [rt.b_stat];\n    }, nt.braceIsBlock = function (t) {\n      var e = this.curContext();\n      return e === rt.f_expr || e === rt.f_stat || (t !== k.colon || e !== rt.b_stat && e !== rt.b_expr ? t === k._return || t === k.name && this.exprAllowed ? E.test(this.input.slice(this.lastTokEnd, this.start)) : t === k._else || t === k.semi || t === k.eof || t === k.parenR || t === k.arrow || (t === k.braceL ? e === rt.b_stat : t !== k._var && t !== k.name && !this.exprAllowed) : !e.isExpr);\n    }, nt.inGeneratorContext = function () {\n      for (var t = this.context.length - 1; t >= 1; t--) {\n        var e = this.context[t];\n        if (\"function\" === e.token) return e.generator;\n      }\n\n      return !1;\n    }, nt.updateContext = function (t) {\n      var e,\n          i = this.type;\n      i.keyword && t === k.dot ? this.exprAllowed = !1 : (e = i.updateContext) ? e.call(this, t) : this.exprAllowed = i.beforeExpr;\n    }, k.parenR.updateContext = k.braceR.updateContext = function () {\n      if (1 !== this.context.length) {\n        var t = this.context.pop();\n        t === rt.b_stat && \"function\" === this.curContext().token && (t = this.context.pop()), this.exprAllowed = !t.isExpr;\n      } else this.exprAllowed = !0;\n    }, k.braceL.updateContext = function (t) {\n      this.context.push(this.braceIsBlock(t) ? rt.b_stat : rt.b_expr), this.exprAllowed = !0;\n    }, k.dollarBraceL.updateContext = function () {\n      this.context.push(rt.b_tmpl), this.exprAllowed = !0;\n    }, k.parenL.updateContext = function (t) {\n      var e = t === k._if || t === k._for || t === k._with || t === k._while;\n      this.context.push(e ? rt.p_stat : rt.p_expr), this.exprAllowed = !0;\n    }, k.incDec.updateContext = function () {}, k._function.updateContext = k._class.updateContext = function (t) {\n      t.beforeExpr && t !== k.semi && t !== k._else && (t !== k.colon && t !== k.braceL || this.curContext() !== rt.b_stat) ? this.context.push(rt.f_expr) : this.context.push(rt.f_stat), this.exprAllowed = !1;\n    }, k.backQuote.updateContext = function () {\n      this.curContext() === rt.q_tmpl ? this.context.pop() : this.context.push(rt.q_tmpl), this.exprAllowed = !1;\n    }, k.star.updateContext = function (t) {\n      if (t === k._function) {\n        var e = this.context.length - 1;\n        this.context[e] === rt.f_expr ? this.context[e] = rt.f_expr_gen : this.context[e] = rt.f_gen;\n      }\n\n      this.exprAllowed = !0;\n    }, k.name.updateContext = function (t) {\n      var e = !1;\n      this.options.ecmaVersion >= 6 && t !== k.dot && (\"of\" === this.value && !this.exprAllowed || \"yield\" === this.value && this.inGeneratorContext()) && (e = !0), this.exprAllowed = e;\n    };\n    var at = {\n      $LONE: [\"ASCII\", \"ASCII_Hex_Digit\", \"AHex\", \"Alphabetic\", \"Alpha\", \"Any\", \"Assigned\", \"Bidi_Control\", \"Bidi_C\", \"Bidi_Mirrored\", \"Bidi_M\", \"Case_Ignorable\", \"CI\", \"Cased\", \"Changes_When_Casefolded\", \"CWCF\", \"Changes_When_Casemapped\", \"CWCM\", \"Changes_When_Lowercased\", \"CWL\", \"Changes_When_NFKC_Casefolded\", \"CWKCF\", \"Changes_When_Titlecased\", \"CWT\", \"Changes_When_Uppercased\", \"CWU\", \"Dash\", \"Default_Ignorable_Code_Point\", \"DI\", \"Deprecated\", \"Dep\", \"Diacritic\", \"Dia\", \"Emoji\", \"Emoji_Component\", \"Emoji_Modifier\", \"Emoji_Modifier_Base\", \"Emoji_Presentation\", \"Extender\", \"Ext\", \"Grapheme_Base\", \"Gr_Base\", \"Grapheme_Extend\", \"Gr_Ext\", \"Hex_Digit\", \"Hex\", \"IDS_Binary_Operator\", \"IDSB\", \"IDS_Trinary_Operator\", \"IDST\", \"ID_Continue\", \"IDC\", \"ID_Start\", \"IDS\", \"Ideographic\", \"Ideo\", \"Join_Control\", \"Join_C\", \"Logical_Order_Exception\", \"LOE\", \"Lowercase\", \"Lower\", \"Math\", \"Noncharacter_Code_Point\", \"NChar\", \"Pattern_Syntax\", \"Pat_Syn\", \"Pattern_White_Space\", \"Pat_WS\", \"Quotation_Mark\", \"QMark\", \"Radical\", \"Regional_Indicator\", \"RI\", \"Sentence_Terminal\", \"STerm\", \"Soft_Dotted\", \"SD\", \"Terminal_Punctuation\", \"Term\", \"Unified_Ideograph\", \"UIdeo\", \"Uppercase\", \"Upper\", \"Variation_Selector\", \"VS\", \"White_Space\", \"space\", \"XID_Continue\", \"XIDC\", \"XID_Start\", \"XIDS\"],\n      General_Category: [\"Cased_Letter\", \"LC\", \"Close_Punctuation\", \"Pe\", \"Connector_Punctuation\", \"Pc\", \"Control\", \"Cc\", \"cntrl\", \"Currency_Symbol\", \"Sc\", \"Dash_Punctuation\", \"Pd\", \"Decimal_Number\", \"Nd\", \"digit\", \"Enclosing_Mark\", \"Me\", \"Final_Punctuation\", \"Pf\", \"Format\", \"Cf\", \"Initial_Punctuation\", \"Pi\", \"Letter\", \"L\", \"Letter_Number\", \"Nl\", \"Line_Separator\", \"Zl\", \"Lowercase_Letter\", \"Ll\", \"Mark\", \"M\", \"Combining_Mark\", \"Math_Symbol\", \"Sm\", \"Modifier_Letter\", \"Lm\", \"Modifier_Symbol\", \"Sk\", \"Nonspacing_Mark\", \"Mn\", \"Number\", \"N\", \"Open_Punctuation\", \"Ps\", \"Other\", \"C\", \"Other_Letter\", \"Lo\", \"Other_Number\", \"No\", \"Other_Punctuation\", \"Po\", \"Other_Symbol\", \"So\", \"Paragraph_Separator\", \"Zp\", \"Private_Use\", \"Co\", \"Punctuation\", \"P\", \"punct\", \"Separator\", \"Z\", \"Space_Separator\", \"Zs\", \"Spacing_Mark\", \"Mc\", \"Surrogate\", \"Cs\", \"Symbol\", \"S\", \"Titlecase_Letter\", \"Lt\", \"Unassigned\", \"Cn\", \"Uppercase_Letter\", \"Lu\"],\n      Script: [\"Adlam\", \"Adlm\", \"Ahom\", \"Anatolian_Hieroglyphs\", \"Hluw\", \"Arabic\", \"Arab\", \"Armenian\", \"Armn\", \"Avestan\", \"Avst\", \"Balinese\", \"Bali\", \"Bamum\", \"Bamu\", \"Bassa_Vah\", \"Bass\", \"Batak\", \"Batk\", \"Bengali\", \"Beng\", \"Bhaiksuki\", \"Bhks\", \"Bopomofo\", \"Bopo\", \"Brahmi\", \"Brah\", \"Braille\", \"Brai\", \"Buginese\", \"Bugi\", \"Buhid\", \"Buhd\", \"Canadian_Aboriginal\", \"Cans\", \"Carian\", \"Cari\", \"Caucasian_Albanian\", \"Aghb\", \"Chakma\", \"Cakm\", \"Cham\", \"Cherokee\", \"Cher\", \"Common\", \"Zyyy\", \"Coptic\", \"Copt\", \"Qaac\", \"Cuneiform\", \"Xsux\", \"Cypriot\", \"Cprt\", \"Cyrillic\", \"Cyrl\", \"Deseret\", \"Dsrt\", \"Devanagari\", \"Deva\", \"Duployan\", \"Dupl\", \"Egyptian_Hieroglyphs\", \"Egyp\", \"Elbasan\", \"Elba\", \"Ethiopic\", \"Ethi\", \"Georgian\", \"Geor\", \"Glagolitic\", \"Glag\", \"Gothic\", \"Goth\", \"Grantha\", \"Gran\", \"Greek\", \"Grek\", \"Gujarati\", \"Gujr\", \"Gurmukhi\", \"Guru\", \"Han\", \"Hani\", \"Hangul\", \"Hang\", \"Hanunoo\", \"Hano\", \"Hatran\", \"Hatr\", \"Hebrew\", \"Hebr\", \"Hiragana\", \"Hira\", \"Imperial_Aramaic\", \"Armi\", \"Inherited\", \"Zinh\", \"Qaai\", \"Inscriptional_Pahlavi\", \"Phli\", \"Inscriptional_Parthian\", \"Prti\", \"Javanese\", \"Java\", \"Kaithi\", \"Kthi\", \"Kannada\", \"Knda\", \"Katakana\", \"Kana\", \"Kayah_Li\", \"Kali\", \"Kharoshthi\", \"Khar\", \"Khmer\", \"Khmr\", \"Khojki\", \"Khoj\", \"Khudawadi\", \"Sind\", \"Lao\", \"Laoo\", \"Latin\", \"Latn\", \"Lepcha\", \"Lepc\", \"Limbu\", \"Limb\", \"Linear_A\", \"Lina\", \"Linear_B\", \"Linb\", \"Lisu\", \"Lycian\", \"Lyci\", \"Lydian\", \"Lydi\", \"Mahajani\", \"Mahj\", \"Malayalam\", \"Mlym\", \"Mandaic\", \"Mand\", \"Manichaean\", \"Mani\", \"Marchen\", \"Marc\", \"Masaram_Gondi\", \"Gonm\", \"Meetei_Mayek\", \"Mtei\", \"Mende_Kikakui\", \"Mend\", \"Meroitic_Cursive\", \"Merc\", \"Meroitic_Hieroglyphs\", \"Mero\", \"Miao\", \"Plrd\", \"Modi\", \"Mongolian\", \"Mong\", \"Mro\", \"Mroo\", \"Multani\", \"Mult\", \"Myanmar\", \"Mymr\", \"Nabataean\", \"Nbat\", \"New_Tai_Lue\", \"Talu\", \"Newa\", \"Nko\", \"Nkoo\", \"Nushu\", \"Nshu\", \"Ogham\", \"Ogam\", \"Ol_Chiki\", \"Olck\", \"Old_Hungarian\", \"Hung\", \"Old_Italic\", \"Ital\", \"Old_North_Arabian\", \"Narb\", \"Old_Permic\", \"Perm\", \"Old_Persian\", \"Xpeo\", \"Old_South_Arabian\", \"Sarb\", \"Old_Turkic\", \"Orkh\", \"Oriya\", \"Orya\", \"Osage\", \"Osge\", \"Osmanya\", \"Osma\", \"Pahawh_Hmong\", \"Hmng\", \"Palmyrene\", \"Palm\", \"Pau_Cin_Hau\", \"Pauc\", \"Phags_Pa\", \"Phag\", \"Phoenician\", \"Phnx\", \"Psalter_Pahlavi\", \"Phlp\", \"Rejang\", \"Rjng\", \"Runic\", \"Runr\", \"Samaritan\", \"Samr\", \"Saurashtra\", \"Saur\", \"Sharada\", \"Shrd\", \"Shavian\", \"Shaw\", \"Siddham\", \"Sidd\", \"SignWriting\", \"Sgnw\", \"Sinhala\", \"Sinh\", \"Sora_Sompeng\", \"Sora\", \"Soyombo\", \"Soyo\", \"Sundanese\", \"Sund\", \"Syloti_Nagri\", \"Sylo\", \"Syriac\", \"Syrc\", \"Tagalog\", \"Tglg\", \"Tagbanwa\", \"Tagb\", \"Tai_Le\", \"Tale\", \"Tai_Tham\", \"Lana\", \"Tai_Viet\", \"Tavt\", \"Takri\", \"Takr\", \"Tamil\", \"Taml\", \"Tangut\", \"Tang\", \"Telugu\", \"Telu\", \"Thaana\", \"Thaa\", \"Thai\", \"Tibetan\", \"Tibt\", \"Tifinagh\", \"Tfng\", \"Tirhuta\", \"Tirh\", \"Ugaritic\", \"Ugar\", \"Vai\", \"Vaii\", \"Warang_Citi\", \"Wara\", \"Yi\", \"Yiii\", \"Zanabazar_Square\", \"Zanb\"]\n    };\n    Array.prototype.push.apply(at.$LONE, at.General_Category), at.gc = at.General_Category, at.sc = at.Script_Extensions = at.scx = at.Script;\n\n    var ot = F.prototype,\n        ht = function (t) {\n      this.parser = t, this.validFlags = \"gim\" + (t.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (t.options.ecmaVersion >= 9 ? \"s\" : \"\"), this.source = \"\", this.flags = \"\", this.start = 0, this.switchU = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = \"\", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];\n    };\n\n    function pt(t) {\n      return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t)));\n    }\n\n    function ct(t) {\n      return 36 === t || t >= 40 && t <= 43 || 46 === t || 63 === t || t >= 91 && t <= 94 || t >= 123 && t <= 125;\n    }\n\n    function ut(t) {\n      return t >= 65 && t <= 90 || t >= 97 && t <= 122;\n    }\n\n    function lt(t) {\n      return ut(t) || 95 === t;\n    }\n\n    function dt(t) {\n      return lt(t) || ft(t);\n    }\n\n    function ft(t) {\n      return t >= 48 && t <= 57;\n    }\n\n    function mt(t) {\n      return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102;\n    }\n\n    function xt(t) {\n      return t >= 65 && t <= 70 ? t - 65 + 10 : t >= 97 && t <= 102 ? t - 97 + 10 : t - 48;\n    }\n\n    function gt(t) {\n      return t >= 48 && t <= 55;\n    }\n\n    ht.prototype.reset = function (t, e, i) {\n      var s = -1 !== i.indexOf(\"u\");\n      this.start = 0 | t, this.source = e + \"\", this.flags = i, this.switchU = s && this.parser.options.ecmaVersion >= 6, this.switchN = s && this.parser.options.ecmaVersion >= 9;\n    }, ht.prototype.raise = function (t) {\n      this.parser.raiseRecoverable(this.start, \"Invalid regular expression: /\" + this.source + \"/: \" + t);\n    }, ht.prototype.at = function (t) {\n      var e = this.source,\n          i = e.length;\n      if (t >= i) return -1;\n      var s = e.charCodeAt(t);\n      return !this.switchU || s <= 55295 || s >= 57344 || t + 1 >= i ? s : (s << 10) + e.charCodeAt(t + 1) - 56613888;\n    }, ht.prototype.nextIndex = function (t) {\n      var e = this.source,\n          i = e.length;\n      if (t >= i) return i;\n      var s = e.charCodeAt(t);\n      return !this.switchU || s <= 55295 || s >= 57344 || t + 1 >= i ? t + 1 : t + 2;\n    }, ht.prototype.current = function () {\n      return this.at(this.pos);\n    }, ht.prototype.lookahead = function () {\n      return this.at(this.nextIndex(this.pos));\n    }, ht.prototype.advance = function () {\n      this.pos = this.nextIndex(this.pos);\n    }, ht.prototype.eat = function (t) {\n      return this.current() === t && (this.advance(), !0);\n    }, ot.validateRegExpFlags = function (t) {\n      for (var e = t.validFlags, i = t.flags, s = 0; s < i.length; s++) {\n        var r = i.charAt(s);\n        -1 === e.indexOf(r) && this.raise(t.start, \"Invalid regular expression flag\"), i.indexOf(r, s + 1) > -1 && this.raise(t.start, \"Duplicate regular expression flag\");\n      }\n    }, ot.validateRegExpPattern = function (t) {\n      this.regexp_pattern(t), !t.switchN && this.options.ecmaVersion >= 9 && t.groupNames.length > 0 && (t.switchN = !0, this.regexp_pattern(t));\n    }, ot.regexp_pattern = function (t) {\n      t.pos = 0, t.lastIntValue = 0, t.lastStringValue = \"\", t.lastAssertionIsQuantifiable = !1, t.numCapturingParens = 0, t.maxBackReference = 0, t.groupNames.length = 0, t.backReferenceNames.length = 0, this.regexp_disjunction(t), t.pos !== t.source.length && (t.eat(41) && t.raise(\"Unmatched ')'\"), (t.eat(93) || t.eat(125)) && t.raise(\"Lone quantifier brackets\")), t.maxBackReference > t.numCapturingParens && t.raise(\"Invalid escape\");\n\n      for (var e = 0, i = t.backReferenceNames; e < i.length; e += 1) {\n        var s = i[e];\n        -1 === t.groupNames.indexOf(s) && t.raise(\"Invalid named capture referenced\");\n      }\n    }, ot.regexp_disjunction = function (t) {\n      for (this.regexp_alternative(t); t.eat(124);) this.regexp_alternative(t);\n\n      this.regexp_eatQuantifier(t, !0) && t.raise(\"Nothing to repeat\"), t.eat(123) && t.raise(\"Lone quantifier brackets\");\n    }, ot.regexp_alternative = function (t) {\n      for (; t.pos < t.source.length && this.regexp_eatTerm(t););\n    }, ot.regexp_eatTerm = function (t) {\n      return this.regexp_eatAssertion(t) ? (t.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(t) && t.switchU && t.raise(\"Invalid quantifier\"), !0) : !(t.switchU ? !this.regexp_eatAtom(t) : !this.regexp_eatExtendedAtom(t)) && (this.regexp_eatQuantifier(t), !0);\n    }, ot.regexp_eatAssertion = function (t) {\n      var e = t.pos;\n      if (t.lastAssertionIsQuantifiable = !1, t.eat(94) || t.eat(36)) return !0;\n\n      if (t.eat(92)) {\n        if (t.eat(66) || t.eat(98)) return !0;\n        t.pos = e;\n      }\n\n      if (t.eat(40) && t.eat(63)) {\n        var i = !1;\n        if (this.options.ecmaVersion >= 9 && (i = t.eat(60)), t.eat(61) || t.eat(33)) return this.regexp_disjunction(t), t.eat(41) || t.raise(\"Unterminated group\"), t.lastAssertionIsQuantifiable = !i, !0;\n      }\n\n      return t.pos = e, !1;\n    }, ot.regexp_eatQuantifier = function (t, e) {\n      return void 0 === e && (e = !1), !!this.regexp_eatQuantifierPrefix(t, e) && (t.eat(63), !0);\n    }, ot.regexp_eatQuantifierPrefix = function (t, e) {\n      return t.eat(42) || t.eat(43) || t.eat(63) || this.regexp_eatBracedQuantifier(t, e);\n    }, ot.regexp_eatBracedQuantifier = function (t, e) {\n      var i = t.pos;\n\n      if (t.eat(123)) {\n        var s = 0,\n            r = -1;\n        if (this.regexp_eatDecimalDigits(t) && (s = t.lastIntValue, t.eat(44) && this.regexp_eatDecimalDigits(t) && (r = t.lastIntValue), t.eat(125))) return -1 !== r && r < s && !e && t.raise(\"numbers out of order in {} quantifier\"), !0;\n        t.switchU && !e && t.raise(\"Incomplete quantifier\"), t.pos = i;\n      }\n\n      return !1;\n    }, ot.regexp_eatAtom = function (t) {\n      return this.regexp_eatPatternCharacters(t) || t.eat(46) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t);\n    }, ot.regexp_eatReverseSolidusAtomEscape = function (t) {\n      var e = t.pos;\n\n      if (t.eat(92)) {\n        if (this.regexp_eatAtomEscape(t)) return !0;\n        t.pos = e;\n      }\n\n      return !1;\n    }, ot.regexp_eatUncapturingGroup = function (t) {\n      var e = t.pos;\n\n      if (t.eat(40)) {\n        if (t.eat(63) && t.eat(58)) {\n          if (this.regexp_disjunction(t), t.eat(41)) return !0;\n          t.raise(\"Unterminated group\");\n        }\n\n        t.pos = e;\n      }\n\n      return !1;\n    }, ot.regexp_eatCapturingGroup = function (t) {\n      if (t.eat(40)) {\n        if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(t) : 63 === t.current() && t.raise(\"Invalid group\"), this.regexp_disjunction(t), t.eat(41)) return t.numCapturingParens += 1, !0;\n        t.raise(\"Unterminated group\");\n      }\n\n      return !1;\n    }, ot.regexp_eatExtendedAtom = function (t) {\n      return t.eat(46) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t) || this.regexp_eatInvalidBracedQuantifier(t) || this.regexp_eatExtendedPatternCharacter(t);\n    }, ot.regexp_eatInvalidBracedQuantifier = function (t) {\n      return this.regexp_eatBracedQuantifier(t, !0) && t.raise(\"Nothing to repeat\"), !1;\n    }, ot.regexp_eatSyntaxCharacter = function (t) {\n      var e = t.current();\n      return !!ct(e) && (t.lastIntValue = e, t.advance(), !0);\n    }, ot.regexp_eatPatternCharacters = function (t) {\n      for (var e = t.pos, i = 0; -1 !== (i = t.current()) && !ct(i);) t.advance();\n\n      return t.pos !== e;\n    }, ot.regexp_eatExtendedPatternCharacter = function (t) {\n      var e = t.current();\n      return !(-1 === e || 36 === e || e >= 40 && e <= 43 || 46 === e || 63 === e || 91 === e || 94 === e || 124 === e) && (t.advance(), !0);\n    }, ot.regexp_groupSpecifier = function (t) {\n      if (t.eat(63)) {\n        if (this.regexp_eatGroupName(t)) return -1 !== t.groupNames.indexOf(t.lastStringValue) && t.raise(\"Duplicate capture group name\"), void t.groupNames.push(t.lastStringValue);\n        t.raise(\"Invalid group\");\n      }\n    }, ot.regexp_eatGroupName = function (t) {\n      if (t.lastStringValue = \"\", t.eat(60)) {\n        if (this.regexp_eatRegExpIdentifierName(t) && t.eat(62)) return !0;\n        t.raise(\"Invalid capture group name\");\n      }\n\n      return !1;\n    }, ot.regexp_eatRegExpIdentifierName = function (t) {\n      if (t.lastStringValue = \"\", this.regexp_eatRegExpIdentifierStart(t)) {\n        for (t.lastStringValue += pt(t.lastIntValue); this.regexp_eatRegExpIdentifierPart(t);) t.lastStringValue += pt(t.lastIntValue);\n\n        return !0;\n      }\n\n      return !1;\n    }, ot.regexp_eatRegExpIdentifierStart = function (t) {\n      var e = t.pos,\n          i = t.current();\n      return t.advance(), 92 === i && this.regexp_eatRegExpUnicodeEscapeSequence(t) && (i = t.lastIntValue), function (t) {\n        return f(t, !0) || 36 === t || 95 === t;\n      }(i) ? (t.lastIntValue = i, !0) : (t.pos = e, !1);\n    }, ot.regexp_eatRegExpIdentifierPart = function (t) {\n      var e = t.pos,\n          i = t.current();\n      return t.advance(), 92 === i && this.regexp_eatRegExpUnicodeEscapeSequence(t) && (i = t.lastIntValue), function (t) {\n        return m(t, !0) || 36 === t || 95 === t || 8204 === t || 8205 === t;\n      }(i) ? (t.lastIntValue = i, !0) : (t.pos = e, !1);\n    }, ot.regexp_eatAtomEscape = function (t) {\n      return !!(this.regexp_eatBackReference(t) || this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t) || t.switchN && this.regexp_eatKGroupName(t)) || (t.switchU && (99 === t.current() && t.raise(\"Invalid unicode escape\"), t.raise(\"Invalid escape\")), !1);\n    }, ot.regexp_eatBackReference = function (t) {\n      var e = t.pos;\n\n      if (this.regexp_eatDecimalEscape(t)) {\n        var i = t.lastIntValue;\n        if (t.switchU) return i > t.maxBackReference && (t.maxBackReference = i), !0;\n        if (i <= t.numCapturingParens) return !0;\n        t.pos = e;\n      }\n\n      return !1;\n    }, ot.regexp_eatKGroupName = function (t) {\n      if (t.eat(107)) {\n        if (this.regexp_eatGroupName(t)) return t.backReferenceNames.push(t.lastStringValue), !0;\n        t.raise(\"Invalid named reference\");\n      }\n\n      return !1;\n    }, ot.regexp_eatCharacterEscape = function (t) {\n      return this.regexp_eatControlEscape(t) || this.regexp_eatCControlLetter(t) || this.regexp_eatZero(t) || this.regexp_eatHexEscapeSequence(t) || this.regexp_eatRegExpUnicodeEscapeSequence(t) || !t.switchU && this.regexp_eatLegacyOctalEscapeSequence(t) || this.regexp_eatIdentityEscape(t);\n    }, ot.regexp_eatCControlLetter = function (t) {\n      var e = t.pos;\n\n      if (t.eat(99)) {\n        if (this.regexp_eatControlLetter(t)) return !0;\n        t.pos = e;\n      }\n\n      return !1;\n    }, ot.regexp_eatZero = function (t) {\n      return 48 === t.current() && !ft(t.lookahead()) && (t.lastIntValue = 0, t.advance(), !0);\n    }, ot.regexp_eatControlEscape = function (t) {\n      var e = t.current();\n      return 116 === e ? (t.lastIntValue = 9, t.advance(), !0) : 110 === e ? (t.lastIntValue = 10, t.advance(), !0) : 118 === e ? (t.lastIntValue = 11, t.advance(), !0) : 102 === e ? (t.lastIntValue = 12, t.advance(), !0) : 114 === e && (t.lastIntValue = 13, t.advance(), !0);\n    }, ot.regexp_eatControlLetter = function (t) {\n      var e = t.current();\n      return !!ut(e) && (t.lastIntValue = e % 32, t.advance(), !0);\n    }, ot.regexp_eatRegExpUnicodeEscapeSequence = function (t) {\n      var e,\n          i = t.pos;\n\n      if (t.eat(117)) {\n        if (this.regexp_eatFixedHexDigits(t, 4)) {\n          var s = t.lastIntValue;\n\n          if (t.switchU && s >= 55296 && s <= 56319) {\n            var r = t.pos;\n\n            if (t.eat(92) && t.eat(117) && this.regexp_eatFixedHexDigits(t, 4)) {\n              var n = t.lastIntValue;\n              if (n >= 56320 && n <= 57343) return t.lastIntValue = 1024 * (s - 55296) + (n - 56320) + 65536, !0;\n            }\n\n            t.pos = r, t.lastIntValue = s;\n          }\n\n          return !0;\n        }\n\n        if (t.switchU && t.eat(123) && this.regexp_eatHexDigits(t) && t.eat(125) && (e = t.lastIntValue) >= 0 && e <= 1114111) return !0;\n        t.switchU && t.raise(\"Invalid unicode escape\"), t.pos = i;\n      }\n\n      return !1;\n    }, ot.regexp_eatIdentityEscape = function (t) {\n      if (t.switchU) return !!this.regexp_eatSyntaxCharacter(t) || !!t.eat(47) && (t.lastIntValue = 47, !0);\n      var e = t.current();\n      return !(99 === e || t.switchN && 107 === e) && (t.lastIntValue = e, t.advance(), !0);\n    }, ot.regexp_eatDecimalEscape = function (t) {\n      t.lastIntValue = 0;\n      var e = t.current();\n\n      if (e >= 49 && e <= 57) {\n        do {\n          t.lastIntValue = 10 * t.lastIntValue + (e - 48), t.advance();\n        } while ((e = t.current()) >= 48 && e <= 57);\n\n        return !0;\n      }\n\n      return !1;\n    }, ot.regexp_eatCharacterClassEscape = function (t) {\n      var e = t.current();\n      if (function (t) {\n        return 100 === t || 68 === t || 115 === t || 83 === t || 119 === t || 87 === t;\n      }(e)) return t.lastIntValue = -1, t.advance(), !0;\n\n      if (t.switchU && this.options.ecmaVersion >= 9 && (80 === e || 112 === e)) {\n        if (t.lastIntValue = -1, t.advance(), t.eat(123) && this.regexp_eatUnicodePropertyValueExpression(t) && t.eat(125)) return !0;\n        t.raise(\"Invalid property name\");\n      }\n\n      return !1;\n    }, ot.regexp_eatUnicodePropertyValueExpression = function (t) {\n      var e = t.pos;\n\n      if (this.regexp_eatUnicodePropertyName(t) && t.eat(61)) {\n        var i = t.lastStringValue;\n\n        if (this.regexp_eatUnicodePropertyValue(t)) {\n          var s = t.lastStringValue;\n          return this.regexp_validateUnicodePropertyNameAndValue(t, i, s), !0;\n        }\n      }\n\n      if (t.pos = e, this.regexp_eatLoneUnicodePropertyNameOrValue(t)) {\n        var r = t.lastStringValue;\n        return this.regexp_validateUnicodePropertyNameOrValue(t, r), !0;\n      }\n\n      return !1;\n    }, ot.regexp_validateUnicodePropertyNameAndValue = function (t, e, i) {\n      at.hasOwnProperty(e) && -1 !== at[e].indexOf(i) || t.raise(\"Invalid property name\");\n    }, ot.regexp_validateUnicodePropertyNameOrValue = function (t, e) {\n      -1 === at.$LONE.indexOf(e) && t.raise(\"Invalid property name\");\n    }, ot.regexp_eatUnicodePropertyName = function (t) {\n      var e = 0;\n\n      for (t.lastStringValue = \"\"; lt(e = t.current());) t.lastStringValue += pt(e), t.advance();\n\n      return \"\" !== t.lastStringValue;\n    }, ot.regexp_eatUnicodePropertyValue = function (t) {\n      var e = 0;\n\n      for (t.lastStringValue = \"\"; dt(e = t.current());) t.lastStringValue += pt(e), t.advance();\n\n      return \"\" !== t.lastStringValue;\n    }, ot.regexp_eatLoneUnicodePropertyNameOrValue = function (t) {\n      return this.regexp_eatUnicodePropertyValue(t);\n    }, ot.regexp_eatCharacterClass = function (t) {\n      if (t.eat(91)) {\n        if (t.eat(94), this.regexp_classRanges(t), t.eat(93)) return !0;\n        t.raise(\"Unterminated character class\");\n      }\n\n      return !1;\n    }, ot.regexp_classRanges = function (t) {\n      for (; this.regexp_eatClassAtom(t);) {\n        var e = t.lastIntValue;\n\n        if (t.eat(45) && this.regexp_eatClassAtom(t)) {\n          var i = t.lastIntValue;\n          !t.switchU || -1 !== e && -1 !== i || t.raise(\"Invalid character class\"), -1 !== e && -1 !== i && e > i && t.raise(\"Range out of order in character class\");\n        }\n      }\n    }, ot.regexp_eatClassAtom = function (t) {\n      var e = t.pos;\n\n      if (t.eat(92)) {\n        if (this.regexp_eatClassEscape(t)) return !0;\n\n        if (t.switchU) {\n          var i = t.current();\n          (99 === i || gt(i)) && t.raise(\"Invalid class escape\"), t.raise(\"Invalid escape\");\n        }\n\n        t.pos = e;\n      }\n\n      var s = t.current();\n      return 93 !== s && (t.lastIntValue = s, t.advance(), !0);\n    }, ot.regexp_eatClassEscape = function (t) {\n      var e = t.pos;\n      if (t.eat(98)) return t.lastIntValue = 8, !0;\n      if (t.switchU && t.eat(45)) return t.lastIntValue = 45, !0;\n\n      if (!t.switchU && t.eat(99)) {\n        if (this.regexp_eatClassControlLetter(t)) return !0;\n        t.pos = e;\n      }\n\n      return this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t);\n    }, ot.regexp_eatClassControlLetter = function (t) {\n      var e = t.current();\n      return !(!ft(e) && 95 !== e) && (t.lastIntValue = e % 32, t.advance(), !0);\n    }, ot.regexp_eatHexEscapeSequence = function (t) {\n      var e = t.pos;\n\n      if (t.eat(120)) {\n        if (this.regexp_eatFixedHexDigits(t, 2)) return !0;\n        t.switchU && t.raise(\"Invalid escape\"), t.pos = e;\n      }\n\n      return !1;\n    }, ot.regexp_eatDecimalDigits = function (t) {\n      var e = t.pos,\n          i = 0;\n\n      for (t.lastIntValue = 0; ft(i = t.current());) t.lastIntValue = 10 * t.lastIntValue + (i - 48), t.advance();\n\n      return t.pos !== e;\n    }, ot.regexp_eatHexDigits = function (t) {\n      var e = t.pos,\n          i = 0;\n\n      for (t.lastIntValue = 0; mt(i = t.current());) t.lastIntValue = 16 * t.lastIntValue + xt(i), t.advance();\n\n      return t.pos !== e;\n    }, ot.regexp_eatLegacyOctalEscapeSequence = function (t) {\n      if (this.regexp_eatOctalDigit(t)) {\n        var e = t.lastIntValue;\n\n        if (this.regexp_eatOctalDigit(t)) {\n          var i = t.lastIntValue;\n          e <= 3 && this.regexp_eatOctalDigit(t) ? t.lastIntValue = 64 * e + 8 * i + t.lastIntValue : t.lastIntValue = 8 * e + i;\n        } else t.lastIntValue = e;\n\n        return !0;\n      }\n\n      return !1;\n    }, ot.regexp_eatOctalDigit = function (t) {\n      var e = t.current();\n      return gt(e) ? (t.lastIntValue = e - 48, t.advance(), !0) : (t.lastIntValue = 0, !1);\n    }, ot.regexp_eatFixedHexDigits = function (t, e) {\n      var i = t.pos;\n      t.lastIntValue = 0;\n\n      for (var s = 0; s < e; ++s) {\n        var r = t.current();\n        if (!mt(r)) return t.pos = i, !1;\n        t.lastIntValue = 16 * t.lastIntValue + xt(r), t.advance();\n      }\n\n      return !0;\n    };\n\n    var yt = function (t) {\n      this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new j(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]);\n    },\n        vt = F.prototype;\n\n    function bt(t) {\n      return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t)));\n    }\n\n    vt.next = function () {\n      this.options.onToken && this.options.onToken(new yt(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();\n    }, vt.getToken = function () {\n      return this.next(), new yt(this);\n    }, \"undefined\" != typeof Symbol && (vt[Symbol.iterator] = function () {\n      var t = this;\n      return {\n        next: function () {\n          var e = t.getToken();\n          return {\n            done: e.type === k.eof,\n            value: e\n          };\n        }\n      };\n    }), vt.curContext = function () {\n      return this.context[this.context.length - 1];\n    }, vt.nextToken = function () {\n      var t = this.curContext();\n      return t && t.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(k.eof) : t.override ? t.override(this) : void this.readToken(this.fullCharCodeAtPos());\n    }, vt.readToken = function (t) {\n      return f(t, this.options.ecmaVersion >= 6) || 92 === t ? this.readWord() : this.getTokenFromCode(t);\n    }, vt.fullCharCodeAtPos = function () {\n      var t = this.input.charCodeAt(this.pos);\n      return t <= 55295 || t >= 57344 ? t : (t << 10) + this.input.charCodeAt(this.pos + 1) - 56613888;\n    }, vt.skipBlockComment = function () {\n      var t,\n          e = this.options.onComment && this.curPosition(),\n          i = this.pos,\n          s = this.input.indexOf(\"*/\", this.pos += 2);\n      if (-1 === s && this.raise(this.pos - 2, \"Unterminated comment\"), this.pos = s + 2, this.options.locations) for (S.lastIndex = i; (t = S.exec(this.input)) && t.index < this.pos;) ++this.curLine, this.lineStart = t.index + t[0].length;\n      this.options.onComment && this.options.onComment(!0, this.input.slice(i + 2, s), i, this.pos, e, this.curPosition());\n    }, vt.skipLineComment = function (t) {\n      for (var e = this.pos, i = this.options.onComment && this.curPosition(), s = this.input.charCodeAt(this.pos += t); this.pos < this.input.length && !w(s);) s = this.input.charCodeAt(++this.pos);\n\n      this.options.onComment && this.options.onComment(!1, this.input.slice(e + t, this.pos), e, this.pos, i, this.curPosition());\n    }, vt.skipSpace = function () {\n      t: for (; this.pos < this.input.length;) {\n        var t = this.input.charCodeAt(this.pos);\n\n        switch (t) {\n          case 32:\n          case 160:\n            ++this.pos;\n            break;\n\n          case 13:\n            10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;\n\n          case 10:\n          case 8232:\n          case 8233:\n            ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);\n            break;\n\n          case 47:\n            switch (this.input.charCodeAt(this.pos + 1)) {\n              case 42:\n                this.skipBlockComment();\n                break;\n\n              case 47:\n                this.skipLineComment(2);\n                break;\n\n              default:\n                break t;\n            }\n\n            break;\n\n          default:\n            if (!(t > 8 && t < 14 || t >= 5760 && C.test(String.fromCharCode(t)))) break t;\n            ++this.pos;\n        }\n      }\n    }, vt.finishToken = function (t, e) {\n      this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());\n      var i = this.type;\n      this.type = t, this.value = e, this.updateContext(i);\n    }, vt.readToken_dot = function () {\n      var t = this.input.charCodeAt(this.pos + 1);\n      if (t >= 48 && t <= 57) return this.readNumber(!0);\n      var e = this.input.charCodeAt(this.pos + 2);\n      return this.options.ecmaVersion >= 6 && 46 === t && 46 === e ? (this.pos += 3, this.finishToken(k.ellipsis)) : (++this.pos, this.finishToken(k.dot));\n    }, vt.readToken_slash = function () {\n      var t = this.input.charCodeAt(this.pos + 1);\n      return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === t ? this.finishOp(k.assign, 2) : this.finishOp(k.slash, 1);\n    }, vt.readToken_mult_modulo_exp = function (t) {\n      var e = this.input.charCodeAt(this.pos + 1),\n          i = 1,\n          s = 42 === t ? k.star : k.modulo;\n      return this.options.ecmaVersion >= 7 && 42 === t && 42 === e && (++i, s = k.starstar, e = this.input.charCodeAt(this.pos + 2)), 61 === e ? this.finishOp(k.assign, i + 1) : this.finishOp(s, i);\n    }, vt.readToken_pipe_amp = function (t) {\n      var e = this.input.charCodeAt(this.pos + 1);\n      return e === t ? this.finishOp(124 === t ? k.logicalOR : k.logicalAND, 2) : 61 === e ? this.finishOp(k.assign, 2) : this.finishOp(124 === t ? k.bitwiseOR : k.bitwiseAND, 1);\n    }, vt.readToken_caret = function () {\n      return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(k.assign, 2) : this.finishOp(k.bitwiseXOR, 1);\n    }, vt.readToken_plus_min = function (t) {\n      var e = this.input.charCodeAt(this.pos + 1);\n      return e === t ? 45 !== e || this.inModule || 62 !== this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && !E.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(k.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : 61 === e ? this.finishOp(k.assign, 2) : this.finishOp(k.plusMin, 1);\n    }, vt.readToken_lt_gt = function (t) {\n      var e = this.input.charCodeAt(this.pos + 1),\n          i = 1;\n      return e === t ? (i = 62 === t && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.pos + i) ? this.finishOp(k.assign, i + 1) : this.finishOp(k.bitShift, i)) : 33 !== e || 60 !== t || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3) ? (61 === e && (i = 2), this.finishOp(k.relational, i)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());\n    }, vt.readToken_eq_excl = function (t) {\n      var e = this.input.charCodeAt(this.pos + 1);\n      return 61 === e ? this.finishOp(k.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === t && 62 === e && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(k.arrow)) : this.finishOp(61 === t ? k.eq : k.prefix, 1);\n    }, vt.getTokenFromCode = function (t) {\n      switch (t) {\n        case 46:\n          return this.readToken_dot();\n\n        case 40:\n          return ++this.pos, this.finishToken(k.parenL);\n\n        case 41:\n          return ++this.pos, this.finishToken(k.parenR);\n\n        case 59:\n          return ++this.pos, this.finishToken(k.semi);\n\n        case 44:\n          return ++this.pos, this.finishToken(k.comma);\n\n        case 91:\n          return ++this.pos, this.finishToken(k.bracketL);\n\n        case 93:\n          return ++this.pos, this.finishToken(k.bracketR);\n\n        case 123:\n          return ++this.pos, this.finishToken(k.braceL);\n\n        case 125:\n          return ++this.pos, this.finishToken(k.braceR);\n\n        case 58:\n          return ++this.pos, this.finishToken(k.colon);\n\n        case 63:\n          return ++this.pos, this.finishToken(k.question);\n\n        case 96:\n          if (this.options.ecmaVersion < 6) break;\n          return ++this.pos, this.finishToken(k.backQuote);\n\n        case 48:\n          var e = this.input.charCodeAt(this.pos + 1);\n          if (120 === e || 88 === e) return this.readRadixNumber(16);\n\n          if (this.options.ecmaVersion >= 6) {\n            if (111 === e || 79 === e) return this.readRadixNumber(8);\n            if (98 === e || 66 === e) return this.readRadixNumber(2);\n          }\n\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n          return this.readNumber(!1);\n\n        case 34:\n        case 39:\n          return this.readString(t);\n\n        case 47:\n          return this.readToken_slash();\n\n        case 37:\n        case 42:\n          return this.readToken_mult_modulo_exp(t);\n\n        case 124:\n        case 38:\n          return this.readToken_pipe_amp(t);\n\n        case 94:\n          return this.readToken_caret();\n\n        case 43:\n        case 45:\n          return this.readToken_plus_min(t);\n\n        case 60:\n        case 62:\n          return this.readToken_lt_gt(t);\n\n        case 61:\n        case 33:\n          return this.readToken_eq_excl(t);\n\n        case 126:\n          return this.finishOp(k.prefix, 1);\n      }\n\n      this.raise(this.pos, \"Unexpected character '\" + bt(t) + \"'\");\n    }, vt.finishOp = function (t, e) {\n      var i = this.input.slice(this.pos, this.pos + e);\n      return this.pos += e, this.finishToken(t, i);\n    }, vt.readRegexp = function () {\n      for (var t, e, i = this.pos;;) {\n        this.pos >= this.input.length && this.raise(i, \"Unterminated regular expression\");\n        var s = this.input.charAt(this.pos);\n        if (E.test(s) && this.raise(i, \"Unterminated regular expression\"), t) t = !1;else {\n          if (\"[\" === s) e = !0;else if (\"]\" === s && e) e = !1;else if (\"/\" === s && !e) break;\n          t = \"\\\\\" === s;\n        }\n        ++this.pos;\n      }\n\n      var r = this.input.slice(i, this.pos);\n      ++this.pos;\n      var n = this.pos,\n          a = this.readWord1();\n      this.containsEsc && this.unexpected(n);\n      var o = this.regexpState || (this.regexpState = new ht(this));\n      o.reset(i, r, a), this.validateRegExpFlags(o), this.validateRegExpPattern(o);\n      var h = null;\n\n      try {\n        h = new RegExp(r, a);\n      } catch (t) {}\n\n      return this.finishToken(k.regexp, {\n        pattern: r,\n        flags: a,\n        value: h\n      });\n    }, vt.readInt = function (t, e) {\n      for (var i = this.pos, s = 0, r = 0, n = null == e ? 1 / 0 : e; r < n; ++r) {\n        var a = this.input.charCodeAt(this.pos),\n            o = void 0;\n        if ((o = a >= 97 ? a - 97 + 10 : a >= 65 ? a - 65 + 10 : a >= 48 && a <= 57 ? a - 48 : 1 / 0) >= t) break;\n        ++this.pos, s = s * t + o;\n      }\n\n      return this.pos === i || null != e && this.pos - i !== e ? null : s;\n    }, vt.readRadixNumber = function (t) {\n      this.pos += 2;\n      var e = this.readInt(t);\n      return null == e && this.raise(this.start + 2, \"Expected number in radix \" + t), f(this.fullCharCodeAtPos()) && this.raise(this.pos, \"Identifier directly after number\"), this.finishToken(k.num, e);\n    }, vt.readNumber = function (t) {\n      var e = this.pos;\n      t || null !== this.readInt(10) || this.raise(e, \"Invalid number\");\n      var i = this.pos - e >= 2 && 48 === this.input.charCodeAt(e);\n      i && this.strict && this.raise(e, \"Invalid number\"), i && /[89]/.test(this.input.slice(e, this.pos)) && (i = !1);\n      var s = this.input.charCodeAt(this.pos);\n      46 !== s || i || (++this.pos, this.readInt(10), s = this.input.charCodeAt(this.pos)), 69 !== s && 101 !== s || i || (43 !== (s = this.input.charCodeAt(++this.pos)) && 45 !== s || ++this.pos, null === this.readInt(10) && this.raise(e, \"Invalid number\")), f(this.fullCharCodeAtPos()) && this.raise(this.pos, \"Identifier directly after number\");\n      var r = this.input.slice(e, this.pos),\n          n = i ? parseInt(r, 8) : parseFloat(r);\n      return this.finishToken(k.num, n);\n    }, vt.readCodePoint = function () {\n      var t;\n\n      if (123 === this.input.charCodeAt(this.pos)) {\n        this.options.ecmaVersion < 6 && this.unexpected();\n        var e = ++this.pos;\n        t = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(e, \"Code point out of bounds\");\n      } else t = this.readHexChar(4);\n\n      return t;\n    }, vt.readString = function (t) {\n      for (var e = \"\", i = ++this.pos;;) {\n        this.pos >= this.input.length && this.raise(this.start, \"Unterminated string constant\");\n        var s = this.input.charCodeAt(this.pos);\n        if (s === t) break;\n        92 === s ? (e += this.input.slice(i, this.pos), e += this.readEscapedChar(!1), i = this.pos) : (w(s, this.options.ecmaVersion >= 10) && this.raise(this.start, \"Unterminated string constant\"), ++this.pos);\n      }\n\n      return e += this.input.slice(i, this.pos++), this.finishToken(k.string, e);\n    };\n    var _t = {};\n    vt.tryReadTemplateToken = function () {\n      this.inTemplateElement = !0;\n\n      try {\n        this.readTmplToken();\n      } catch (t) {\n        if (t !== _t) throw t;\n        this.readInvalidTemplateToken();\n      }\n\n      this.inTemplateElement = !1;\n    }, vt.invalidStringToken = function (t, e) {\n      if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw _t;\n      this.raise(t, e);\n    }, vt.readTmplToken = function () {\n      for (var t = \"\", e = this.pos;;) {\n        this.pos >= this.input.length && this.raise(this.start, \"Unterminated template\");\n        var i = this.input.charCodeAt(this.pos);\n        if (96 === i || 36 === i && 123 === this.input.charCodeAt(this.pos + 1)) return this.pos !== this.start || this.type !== k.template && this.type !== k.invalidTemplate ? (t += this.input.slice(e, this.pos), this.finishToken(k.template, t)) : 36 === i ? (this.pos += 2, this.finishToken(k.dollarBraceL)) : (++this.pos, this.finishToken(k.backQuote));\n        if (92 === i) t += this.input.slice(e, this.pos), t += this.readEscapedChar(!0), e = this.pos;else if (w(i)) {\n          switch (t += this.input.slice(e, this.pos), ++this.pos, i) {\n            case 13:\n              10 === this.input.charCodeAt(this.pos) && ++this.pos;\n\n            case 10:\n              t += \"\\n\";\n              break;\n\n            default:\n              t += String.fromCharCode(i);\n          }\n\n          this.options.locations && (++this.curLine, this.lineStart = this.pos), e = this.pos;\n        } else ++this.pos;\n      }\n    }, vt.readInvalidTemplateToken = function () {\n      for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {\n        case \"\\\\\":\n          ++this.pos;\n          break;\n\n        case \"$\":\n          if (\"{\" !== this.input[this.pos + 1]) break;\n\n        case \"`\":\n          return this.finishToken(k.invalidTemplate, this.input.slice(this.start, this.pos));\n      }\n\n      this.raise(this.start, \"Unterminated template\");\n    }, vt.readEscapedChar = function (t) {\n      var e = this.input.charCodeAt(++this.pos);\n\n      switch (++this.pos, e) {\n        case 110:\n          return \"\\n\";\n\n        case 114:\n          return \"\\r\";\n\n        case 120:\n          return String.fromCharCode(this.readHexChar(2));\n\n        case 117:\n          return bt(this.readCodePoint());\n\n        case 116:\n          return \"\\t\";\n\n        case 98:\n          return \"\\b\";\n\n        case 118:\n          return \"\\v\";\n\n        case 102:\n          return \"\\f\";\n\n        case 13:\n          10 === this.input.charCodeAt(this.pos) && ++this.pos;\n\n        case 10:\n          return this.options.locations && (this.lineStart = this.pos, ++this.curLine), \"\";\n\n        default:\n          if (e >= 48 && e <= 55) {\n            var i = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0],\n                s = parseInt(i, 8);\n            return s > 255 && (i = i.slice(0, -1), s = parseInt(i, 8)), this.pos += i.length - 1, e = this.input.charCodeAt(this.pos), \"0\" === i && 56 !== e && 57 !== e || !this.strict && !t || this.invalidStringToken(this.pos - 1 - i.length, t ? \"Octal literal in template string\" : \"Octal literal in strict mode\"), String.fromCharCode(s);\n          }\n\n          return String.fromCharCode(e);\n      }\n    }, vt.readHexChar = function (t) {\n      var e = this.pos,\n          i = this.readInt(16, t);\n      return null === i && this.invalidStringToken(e, \"Bad character escape sequence\"), i;\n    }, vt.readWord1 = function () {\n      this.containsEsc = !1;\n\n      for (var t = \"\", e = !0, i = this.pos, s = this.options.ecmaVersion >= 6; this.pos < this.input.length;) {\n        var r = this.fullCharCodeAtPos();\n        if (m(r, s)) this.pos += r <= 65535 ? 1 : 2;else {\n          if (92 !== r) break;\n          this.containsEsc = !0, t += this.input.slice(i, this.pos);\n          var n = this.pos;\n          117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"), ++this.pos;\n          var a = this.readCodePoint();\n          (e ? f : m)(a, s) || this.invalidStringToken(n, \"Invalid Unicode escape\"), t += bt(a), i = this.pos;\n        }\n        e = !1;\n      }\n\n      return t + this.input.slice(i, this.pos);\n    }, vt.readWord = function () {\n      var t = this.readWord1(),\n          e = k.name;\n      return this.keywords.test(t) && (this.containsEsc && this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + t), e = b[t]), this.finishToken(e, t);\n    };\n    var kt,\n        Et,\n        St,\n        wt = \"5.7.3\";\n\n    function Ct(t, e) {\n      return new F(e, t).parse();\n    }\n\n    function At(t, e, i) {\n      var s = new F(i, t, e);\n      return s.nextToken(), s.parseExpression();\n    }\n\n    function Tt(t, e) {\n      return new F(e, t);\n    }\n\n    function Pt(t, e, i) {\n      kt = t, Et = e, St = i;\n    }\n  }, function (t, e, i) {\n    \"use strict\";\n\n    i.r(e);\n    var s = i(1),\n        r = i(0),\n        n = i.n(r),\n        a = {\n      class: \"className\",\n      for: \"htmlFor\",\n      maxlength: \"maxLength\",\n      colspan: \"colSpan\",\n      rowspan: \"rowSpan\"\n    },\n        o = [\"area\", \"base\", \"br\", \"col\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"],\n        h = [\"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\"];\n\n    var p = function () {\n      return function () {\n        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"\",\n            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16,\n            i = String(t),\n            s = 0;\n        return i.split(\"\").forEach(function (t) {\n          s = (s << 5) - s + t.charCodeAt(0), s &= s;\n        }), Math.abs(s).toString(e);\n      }(Math.random().toString());\n    };\n\n    function c(t, e) {\n      var i = Object.keys(t);\n      return Object.getOwnPropertySymbols && i.push.apply(i, Object.getOwnPropertySymbols(t)), e && (i = i.filter(function (e) {\n        return Object.getOwnPropertyDescriptor(t, e).enumerable;\n      })), i;\n    }\n\n    function u(t, e, i) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: i,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = i, t;\n    }\n\n    function l(t) {\n      return (l = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n\n    function d(t) {\n      switch (l(t)) {\n        case \"string\":\n          return t.split(\";\").filter(function (t) {\n            return t;\n          }).reduce(function (t, e) {\n            var i = e.slice(0, e.indexOf(\":\")).trim(),\n                s = e.slice(e.indexOf(\":\") + 1).trim();\n            return function (t) {\n              for (var e = 1; e < arguments.length; e++) {\n                var i = null != arguments[e] ? arguments[e] : {};\n                e % 2 ? c(i, !0).forEach(function (e) {\n                  u(t, e, i[e]);\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : c(i).forEach(function (e) {\n                  Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));\n                });\n              }\n\n              return t;\n            }({}, t, u({}, i.replace(/([A-Z])([A-Z])/g, \"$1 $2\").replace(/([a-z])([A-Z])/g, \"$1 $2\").replace(/[^a-zA-Z\\u00C0-\\u00ff]/g, \" \").toLowerCase().split(\" \").filter(function (t) {\n              return t;\n            }).map(function (t, e) {\n              return e > 0 ? t[0].toUpperCase() + t.slice(1) : t;\n            }).join(\"\"), s));\n          }, {});\n\n        case \"object\":\n          return t;\n\n        default:\n          return;\n      }\n    }\n\n    function f(t) {\n      return function (t) {\n        if (Array.isArray(t)) return t;\n      }(t) || function (t) {\n        if (Symbol.iterator in Object(t) || \"[object Arguments]\" === Object.prototype.toString.call(t)) return Array.from(t);\n      }(t) || function () {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }();\n    }\n\n    var m = function (t, e) {\n      return function t(e, i) {\n        var s = f(i),\n            r = s[0],\n            n = s.slice(1);\n        if (null != e && null != r) return 0 === n.length ? e[r] : t(e[r], n);\n      }(t, function (t) {\n        return null == t || \"\" === t ? [] : t.split(\".\");\n      }(e));\n    };\n\n    function x(t) {\n      return (x = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      })(t);\n    }\n\n    function g(t, e) {\n      return function (t) {\n        if (Array.isArray(t)) return t;\n      }(t) || function (t, e) {\n        var i = [],\n            s = !0,\n            r = !1,\n            n = void 0;\n\n        try {\n          for (var a, o = t[Symbol.iterator](); !(s = (a = o.next()).done) && (i.push(a.value), !e || i.length !== e); s = !0);\n        } catch (t) {\n          r = !0, n = t;\n        } finally {\n          try {\n            s || null == o.return || o.return();\n          } finally {\n            if (r) throw n;\n          }\n        }\n\n        return i;\n      }(t, e) || function () {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }();\n    }\n\n    function y(t) {\n      return function (t) {\n        if (Array.isArray(t)) {\n          for (var e = 0, i = new Array(t.length); e < t.length; e++) i[e] = t[e];\n\n          return i;\n        }\n      }(t) || function (t) {\n        if (Symbol.iterator in Object(t) || \"[object Arguments]\" === Object.prototype.toString.call(t)) return Array.from(t);\n      }(t) || function () {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n      }();\n    }\n\n    function v(t) {\n      return (v = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n        return t.__proto__ || Object.getPrototypeOf(t);\n      })(t);\n    }\n\n    function b(t) {\n      if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return t;\n    }\n\n    function _(t, e) {\n      return (_ = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    function k(t, e, i) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: i,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = i, t;\n    }\n\n    i.d(e, \"default\", function () {\n      return S;\n    });\n\n    var E = {\n      plugins: {\n        jsx: !0\n      }\n    },\n        S = function (t) {\n      function e() {\n        var t, i, c, u;\n        !function (t, e) {\n          if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, e);\n\n        for (var l = arguments.length, f = new Array(l), _ = 0; _ < l; _++) f[_] = arguments[_];\n\n        return c = this, u = (t = v(e)).call.apply(t, [this].concat(f)), i = !u || \"object\" !== x(u) && \"function\" != typeof u ? b(c) : u, k(b(i), \"parseJSX\", function (t) {\n          var e = \"<root>\".concat(t, \"</root>\"),\n              r = [];\n\n          try {\n            r = (r = new s.Parser(E, e).parse()).body[0].expression.children || [];\n          } catch (t) {\n            return i.props.showWarnings && console.warn(t), i.props.onError && i.props.onError(t), [];\n          }\n\n          return r.map(i.parseExpression).filter(Boolean);\n        }), k(b(i), \"parseExpression\", function (t) {\n          switch (t.type) {\n            case \"JSXElement\":\n              return i.parseElement(t);\n\n            case \"JSXText\":\n              var e = i.props.disableKeyGeneration ? void 0 : p();\n              return i.props.disableFragments ? t.value : n.a.createElement(r.Fragment, {\n                key: e\n              }, t.value);\n\n            case \"JSXAttribute\":\n              return null === t.value || i.parseExpression(t.value);\n\n            case \"ConditionalExpression\":\n              return i.parseExpression(t.test) ? i.parseExpression(t.consequent) : i.parseExpression(t.alternate);\n\n            case \"ArrayExpression\":\n              return t.elements.map(i.parseExpression);\n\n            case \"ObjectExpression\":\n              var s = {};\n              return t.properties.forEach(function (t) {\n                s[t.key.name || t.key.value] = i.parseExpression(t.value);\n              }), s;\n\n            case \"Identifier\":\n              return (i.props.bindings || {})[t.name];\n\n            case \"JSXExpressionContainer\":\n              return i.parseExpression(t.expression);\n\n            case \"Literal\":\n              return t.value;\n\n            case \"MemberExpression\":\n              return (i.parseExpression(t.object) || {})[t.property.name];\n\n            case \"CallExpression\":\n              var a = i.parseExpression(t.callee);\n              return void 0 === a ? void i.props.onError(new Error(\"The expression '\".concat(t.callee, \"' could not be resolved, resulting in an undefined return value.\"))) : a.apply(void 0, y(t.arguments.map(i.parseExpression)));\n\n            case \"LogicalExpression\":\n              var o = i.parseExpression(t.left);\n              return !(\"||\" !== t.operator || !o) || !!(\"&&\" === t.operator && o || \"||\" === t.operator && !o) && i.parseExpression(t.right);\n\n            case \"BinaryExpression\":\n              switch (t.operator) {\n                case \"+\":\n                  return i.parseExpression(t.left) + i.parseExpression(t.right);\n\n                case \"-\":\n                  return i.parseExpression(t.left) - i.parseExpression(t.right);\n\n                case \"*\":\n                  return i.parseExpression(t.left) * i.parseExpression(t.right);\n\n                case \"/\":\n                  return i.parseExpression(t.left) / i.parseExpression(t.right);\n\n                case \"==\":\n                  return (i.parseExpression(t.left) == i.parseExpression(t.right)).toString();\n\n                case \"!=\":\n                  return (i.parseExpression(t.left) != i.parseExpression(t.right)).toString();\n\n                case \"===\":\n                  return (i.parseExpression(t.left) === i.parseExpression(t.right)).toString();\n\n                case \"!==\":\n                  return (i.parseExpression(t.left) !== i.parseExpression(t.right)).toString();\n              }\n\n              break;\n\n            case \"UnaryExpression\":\n              switch (t.operator) {\n                case \"+\":\n                  return t.argument.value;\n\n                case \"-\":\n                  return -1 * t.argument.value;\n\n                case \"!\":\n                  return (!t.argument.value).toString();\n              }\n\n          }\n        }), k(b(i), \"parseName\", function (t) {\n          switch (t.type) {\n            case \"JSXIdentifier\":\n              return t.name;\n\n            case \"JSXMemberExpression\":\n              return \"\".concat(i.parseName(t.object), \".\").concat(i.parseName(t.property));\n          }\n        }), k(b(i), \"parseElement\", function (t) {\n          var e = i.props,\n              s = e.allowUnknownElements,\n              r = e.components,\n              c = void 0 === r ? {} : r,\n              u = e.componentsOnly,\n              l = e.onError,\n              f = t.children,\n              y = void 0 === f ? [] : f,\n              v = t.openingElement,\n              b = v.attributes,\n              _ = void 0 === b ? [] : b,\n              k = i.parseName(v.name);\n\n          if (k) {\n            var E = (i.props.blacklistedAttrs || []).map(function (t) {\n              return t instanceof RegExp ? t : new RegExp(t, \"i\");\n            }),\n                S = (i.props.blacklistedTags || []).map(function (t) {\n              return t.trim().toLowerCase();\n            }).filter(Boolean);\n            if (/^(html|head|body)$/i.test(k)) return y.map(function (t) {\n              return i.parseElement(t);\n            });\n            var w = k.trim().toLowerCase();\n\n            if (-1 === S.indexOf(w)) {\n              if (!m(c, k)) {\n                if (u) return void l(new Error(\"The componenet <\".concat(k, \"> is unrecognized, and will not be rendered.\")));\n                if (!s && document.createElement(k) instanceof HTMLUnknownElement) return void l(new Error(\"The tag <\".concat(k, \"> is unrecognized in this browser, and will not be rendered.\")));\n              }\n\n              var C,\n                  A = m(c, k);\n              if (A || function (t) {\n                return -1 === o.indexOf(t.toLowerCase());\n              }(k)) if (C = y.map(i.parseExpression), A || function (t) {\n                return -1 !== h.indexOf(t.toLowerCase());\n              }(k) || (C = C.filter(function (t) {\n                return \"string\" != typeof t || !/^\\s*$/.test(t);\n              })), 0 === C.length) C = void 0;else if (1 === C.length) {\n                C = g(C, 1)[0];\n              }\n              var T = {\n                key: i.props.disableKeyGeneration ? void 0 : p()\n              };\n              return _.forEach(function (t) {\n                if (\"JSXAttribute\" === t.type) {\n                  var e = t.name.name,\n                      s = a[e] || e,\n                      r = i.parseExpression(t);\n                  0 === E.filter(function (t) {\n                    return t.test(s);\n                  }).length && (T[s] = \"true\" === r || \"false\" === r ? \"true\" === r : r);\n                } else if (\"JSXSpreadAttribute\" === t.type && \"Identifier\" === t.argument.type || \"MemberExpression\" === t.argument.type) {\n                  var n = i.parseExpression(t.argument);\n                  \"object\" === x(n) && Object.keys(n).forEach(function (t) {\n                    var e = a[t] || t;\n                    0 === E.filter(function (t) {\n                      return t.test(e);\n                    }).length && (T[e] = n[t]);\n                  });\n                }\n              }), \"string\" == typeof T.style && (T.style = d(T.style)), C && (T.children = C), n.a.createElement(A || k.toLowerCase(), T);\n            }\n\n            l(new Error(\"The tag <\".concat(k, \"> is blacklisted, and will not be rendered.\")));\n          } else l(new Error(\"The <\".concat(v.name, \"> tag could not be parsed, and will not be rendered.\")));\n        }), k(b(i), \"render\", function () {\n          var t = (i.props.jsx || \"\").trim().replace(/<!DOCTYPE([^>]*)>/g, \"\");\n          return i.ParsedChildren = i.parseJSX(t), i.props.renderInWrapper ? n.a.createElement(\"div\", {\n            className: \"jsx-parser\"\n          }, i.ParsedChildren) : n.a.createElement(n.a.Fragment, null, i.ParsedChildren);\n        }), i;\n      }\n\n      return function (t, e) {\n        if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n        t.prototype = Object.create(e && e.prototype, {\n          constructor: {\n            value: t,\n            writable: !0,\n            configurable: !0\n          }\n        }), e && _(t, e);\n      }(e, r[\"Component\"]), e;\n    }();\n\n    k(S, \"displayName\", \"JsxParser\"), k(S, \"defaultProps\", {\n      allowUnknownElements: !0,\n      bindings: {},\n      blacklistedAttrs: [/^on.+/i],\n      blacklistedTags: [\"script\"],\n      components: [],\n      componentsOnly: !1,\n      disableFragments: !1,\n      disableKeyGeneration: !1,\n      jsx: \"\",\n      onError: function () {},\n      showWarnings: !1,\n      renderInWrapper: !0\n    });\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}